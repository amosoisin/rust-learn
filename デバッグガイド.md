# デバッグガイド

[[README|← トップに戻る]]

---

## 🎯 このガイドの目的

Rustのコンパイラエラーを正しく読み解き、素早く問題を解決するための実践的なガイドです。C言語とは異なるRust特有のエラーパターンを理解し、効率的にデバッグできるようになります。

---

## 📖 Rustのコンパイラエラーの読み方

### 基本原則：**下から上に読む**

C言語のコンパイラとは異なり、Rustのエラーメッセージは**最も重要な情報が下にある**ことが多いです。

```rust
// 例：エラーが発生するコード
fn main() {
    let s = String::from("hello");
    let r1 = &s;
    let r2 = &mut s;  // ← ここでエラー
}
```

**エラーメッセージ：**

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:4:14
  |
3 |     let r1 = &s;
  |              -- immutable borrow occurs here
4 |     let r2 = &mut s;
  |              ^^^^^^ mutable borrow occurs here
5 | }
  | - immutable borrow later used here
```

**読み方のステップ：**

1. **エラーコードを確認**：`error[E0502]` → このコードで検索すると詳細な説明が見つかる
2. **エラーの本質を読む**：「cannot borrow `s` as mutable because it is also borrowed as immutable」
3. **場所を確認**：`--> src/main.rs:4:14` → 4行目、14文字目
4. **詳細な説明を読む**：`^^`で示された箇所が問題の場所
5. **ヒントを確認**：`immutable borrow occurs here`などの補足説明

### エラーコードの活用

エラーコードで詳しい説明を確認できます：

```bash
# エラーコードの詳細を表示
rustc --explain E0502

# または公式ドキュメントで検索
# https://doc.rust-lang.org/error-index.html#E0502
```

---

## 🛠️ Cargoツールの使い分け

### 1. `cargo check`

**用途：** 高速な型チェック（コンパイルはしない）

```bash
cargo check
```

**いつ使う？**
- コードを書いている最中、頻繁に実行
- コンパイルより10倍速い
- 型エラーや借用エラーをすぐに検出

**C言語との違い：**
C言語では`gcc -fsyntax-only`に相当しますが、Rustでは型システムが強力なので、`cargo check`だけでほとんどのバグを検出できます。

---

### 2. `cargo build`

**用途：** 実際にバイナリをコンパイル

```bash
# デバッグビルド（デフォルト）
cargo build

# リリースビルド（最適化）
cargo build --release
```

**いつ使う？**
- 実際に実行したいとき
- パフォーマンスをテストしたいとき（--releaseで）

**C言語との違い：**
- デバッグビルドは`gcc -g`相当
- リリースビルドは`gcc -O3`相当

---

### 3. `cargo clippy`

**用途：** より詳細な静的解析とコード品質チェック

```bash
cargo clippy
```

**いつ使う？**
- コードレビュー前
- ベストプラクティスに従っているか確認
- パフォーマンスの改善提案を得る

**例：**

```rust
// ❌ clippyが警告するコード
let x = &String::from("hello");
// 警告: 直接&strを使うべき

// ✅ 修正後
let x = "hello";
```

**C言語との違い：**
C言語の`cppcheck`や`splint`に近いですが、Rustのclippyははるかに高機能で、コンパイラと統合されています。

---

### 4. `cargo fmt`

**用途：** コードフォーマットの自動整形

```bash
# フォーマットを適用
cargo fmt

# チェックのみ（CIで使用）
cargo fmt -- --check
```

**いつ使う？**
- コミット前
- チームで統一されたスタイルを維持

**C言語との違い：**
`clang-format`に相当しますが、Rustでは`rustfmt`が公式ツールとして標準化されています。

---

## 🔥 C言語プログラマーがよく遭遇するエラー

### エラー1：借用チェッカーエラー（Borrow Checker Errors）

**C言語での考え方：**
```c
// C言語では問題ない
char *s = "hello";
char *r1 = s;
char *r2 = s;  // OK: 両方とも同じポインタを指す
```

**Rustでのエラー：**
```rust
// ❌ エラー
let s = String::from("hello");
let r1 = &s;
let r2 = &mut s;  // error[E0502]
```

**原因：**
Rustでは「不変参照」と「可変参照」を同時に持てません。

**修正：**
```rust
// ✅ 修正1: すべて不変参照
let s = String::from("hello");
let r1 = &s;
let r2 = &s;  // OK

// ✅ 修正2: 可変参照のみ
let mut s = String::from("hello");
let r = &mut s;  // OK
```

**★ Rustの哲学：**
データ競合を**コンパイル時**に防ぐため、以下のルールがあります：
- 任意の数の不変参照 **または** 1つの可変参照のみ
- 参照はデータの有効期間内のみ有効

---

### エラー2：ムーブエラー（Move Errors）

**C言語での考え方：**
```c
// C言語では問題ない
char *s1 = malloc(10);
char *s2 = s1;  // s1もs2も同じメモリを指す
printf("%s", s1);  // OK: まだ使える
```

**Rustでのエラー：**
```rust
// ❌ エラー
let s1 = String::from("hello");
let s2 = s1;  // s1の所有権がs2に移動
println!("{}", s1);  // error[E0382]: borrow of moved value
```

**原因：**
Rustでは所有権が**移動（move）**します。s1はもう使えません。

**修正：**
```rust
// ✅ 修正1: クローン
let s1 = String::from("hello");
let s2 = s1.clone();  // 明示的にコピー
println!("{}", s1);  // OK

// ✅ 修正2: 借用
let s1 = String::from("hello");
let s2 = &s1;  // 借用（所有権は移動しない）
println!("{}", s1);  // OK
```

**C言語との比較：**
```
C言語:
  s1 → [メモリ]
  s2 → [メモリ]  (同じメモリを指す)
  ※ 二重freeのリスク

Rust:
  s1 → [無効]
  s2 → [メモリ]  (所有権が移動)
  ※ コンパイラが二重freeを防ぐ
```

---

### エラー3：ライフタイムエラー（Lifetime Errors）

**C言語での考え方：**
```c
// ❌ C言語でのよくあるバグ（コンパイルは通るが実行時エラー）
char* dangling() {
    char str[] = "hello";
    return str;  // ダングリングポインタ！
}
```

**Rustでのエラー：**
```rust
// ❌ コンパイルエラー
fn dangling() -> &str {
    let s = String::from("hello");
    &s  // error[E0515]: cannot return reference to local variable
}
```

**原因：**
関数を抜けると`s`が破棄されるため、その参照を返せません。

**修正：**
```rust
// ✅ 修正: 所有権を返す
fn not_dangling() -> String {
    String::from("hello")  // 所有権を返す
}
```

**★ Rustの利点：**
C言語ではダングリングポインタが**実行時**にクラッシュしますが、Rustでは**コンパイル時**にエラーになります。

---

### エラー4：型の不一致（Type Mismatch）

**よくあるパターン：**

```rust
// ❌ エラー
fn add(a: i32, b: i32) -> i32 {
    a + b;  // error[E0308]: mismatched types
}
```

**原因：**
セミコロン`;`があるため、`()`（unit型）を返しています。

**修正：**
```rust
// ✅ 修正: セミコロンを削除
fn add(a: i32, b: i32) -> i32 {
    a + b  // セミコロンなし = 値を返す
}
```

**C言語との違い：**
```c
// C言語では return 必須
int add(int a, int b) {
    return a + b;  // returnキーワードが必要
}
```

Rustでは最後の式が戻り値になります（`return`は省略可能）。

---

## 🐛 実践的なデバッグワークフロー

### ステップ1: まず `cargo check` を実行

```bash
cargo check
```

最も高速に型エラーを検出します。

---

### ステップ2: エラーメッセージを**下から上に**読む

```
error[E0382]: borrow of moved value: `s`
 --> src/main.rs:4:20
  |
2 |     let s = String::from("hello");
  |         - move occurs because `s` has type `String`
3 |     let t = s;
  |             - value moved here
4 |     println!("{}", s);
  |                    ^ value borrowed here after move
```

**読み方：**
1. 4行目で`s`を使おうとしている
2. 3行目で`s`が移動（move）している
3. だから4行目で使えない

---

### ステップ3: エラーコードで検索

```bash
rustc --explain E0382
```

または、Googleで「rust E0382」と検索。

---

### ステップ4: `cargo clippy` で追加の警告を確認

```bash
cargo clippy
```

コンパイルは通るが、より良い書き方がある場合に警告してくれます。

---

### ステップ5: `cargo fmt` でコードを整形

```bash
cargo fmt
```

読みやすいコードにすると、エラーを見つけやすくなります。

---

## 🔍 よくあるエラーコード一覧

| エラーコード | 意味 | 頻度 |
|------------|------|------|
| E0382 | 移動した値の借用 | ⭐️⭐️⭐️⭐️⭐️ |
| E0502 | 不変借用中に可変借用 | ⭐️⭐️⭐️⭐️⭐️ |
| E0499 | 複数の可変借用 | ⭐️⭐️⭐️⭐️ |
| E0515 | ローカル変数への参照を返す | ⭐️⭐️⭐️⭐️ |
| E0308 | 型の不一致 | ⭐️⭐️⭐️ |
| E0425 | 未定義の変数 | ⭐️⭐️⭐️ |
| E0277 | トレイト境界が満たされていない | ⭐️⭐️ |

---

## 💡 デバッグのコツ

### 1. コンパイラを信じる

Rustのコンパイラエラーは**正しい**です。「たぶん動くだろう」と無理やり修正しても、別のエラーが出ます。エラーメッセージをよく読んで、**なぜエラーなのか**を理解しましょう。

### 2. 小さく分割して確認

エラーが複雑な場合、コードを小さく分割してテストします。

```rust
// ❌ 複雑すぎてエラーがわかりにくい
let result = data.iter().filter(|x| x.is_valid()).map(|x| x.process()).collect();

// ✅ ステップごとに分割
let filtered: Vec<_> = data.iter().filter(|x| x.is_valid()).collect();
println!("Filtered: {:?}", filtered);  // ここまでOKか確認

let processed: Vec<_> = filtered.iter().map(|x| x.process()).collect();
println!("Processed: {:?}", processed);  // ここまでOKか確認
```

### 3. `dbg!` マクロを活用

C言語の`printf`デバッグに相当するのが`dbg!`マクロです。

```rust
let x = 5;
let y = 10;
dbg!(x);  // [src/main.rs:3] x = 5
dbg!(x + y);  // [src/main.rs:4] x + y = 15
```

**`println!`との違い：**
- ファイル名と行番号を自動で表示
- 変数名も表示される
- 式をそのまま渡せる（値は消費されない）

---

## 🎯 演習問題

以下のコードのエラーを修正してみましょう。

### 問題1：

```rust
fn main() {
    let s = String::from("hello");
    let r1 = &s;
    let r2 = &mut s;
    println!("{} {}", r1, r2);
}
```

> [!note]- 解答を見る
>
> **エラー：** `error[E0502]` - 不変借用中に可変借用できない
>
> **修正：**
> ```rust
> fn main() {
>     let mut s = String::from("hello");
>     let r1 = &s;
>     println!("{}", r1);
>
>     let r2 = &mut s;  // r1のスコープが終わった後
>     println!("{}", r2);
> }
> ```

---

### 問題2：

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);
}
```

> [!note]- 解答を見る
>
> **エラー：** `error[E0382]` - 移動した値の借用
>
> **修正1（クローン）：**
> ```rust
> fn main() {
>     let s1 = String::from("hello");
>     let s2 = s1.clone();
>     println!("{}", s1);  // OK
> }
> ```
>
> **修正2（借用）：**
> ```rust
> fn main() {
>     let s1 = String::from("hello");
>     let s2 = &s1;
>     println!("{}", s1);  // OK
> }
> ```

---

### 問題3：

```rust
fn get_length(s: &String) -> usize {
    s.len();
}

fn main() {
    let s = String::from("hello");
    let len = get_length(&s);
    println!("Length: {}", len);
}
```

> [!note]- 解答を見る
>
> **エラー：** `error[E0308]` - 型の不一致（`()`が返されている）
>
> **修正：**
> ```rust
> fn get_length(s: &String) -> usize {
>     s.len()  // セミコロンを削除
> }
>
> fn main() {
>     let s = String::from("hello");
>     let len = get_length(&s);
>     println!("Length: {}", len);
> }
> ```

---

## 🔗 参考資料

- [Rust Compiler Error Index](https://doc.rust-lang.org/error-index.html) - すべてのエラーコードの詳細
- [The Rust Book - Error Handling](https://doc.rust-jp.rs/book-ja/ch09-00-error-handling.html)
- [Clippy Lints](https://rust-lang.github.io/rust-clippy/master/) - すべてのclippy警告の一覧

---

[[README|トップに戻る]]
