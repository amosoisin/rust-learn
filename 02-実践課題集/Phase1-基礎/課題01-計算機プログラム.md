# 課題01: 計算機プログラム

[[README|← トップに戻る]]  |  [[課題02-文字列操作ツール|次の課題 →]]

**難易度:** ⭐️
**学習時間目安:** 2-3時間
**学習トピック:** 基本構文、型システム、関数、パターンマッチング、Option型

---

## 🎯 課題の目的

Rustの基本構文と型システムに慣れることを目的とした、シンプルな計算機プログラムを作成します。

### 学ぶこと
- 変数と型（特に整数型）
- 関数の定義と戻り値
- `enum` と `match` によるパターンマッチング
- `Option<T>` 型の基礎
- 標準入力の取得（`std::env::args`）
- **式ベースの言語としてのRust**（セミコロンの有無）

---

## 📋 仕様

コマンドライン引数から数式を受け取り、結果を出力する計算機を作成してください。

### 基本機能
```bash
$ cargo run -- 10 + 20
30

$ cargo run -- 100 - 42
58

$ cargo run -- 6 * 7
42

$ cargo run -- 100 / 5
20
```

### 対応する演算子
- `+`: 加算
- `-`: 減算
- `*`: 乗算
- `/`: 除算（整数除算）

### エラーハンドリング（シンプル版）
```bash
$ cargo run -- 10 / 0
Error: Division by zero

$ cargo run -- 10 + abc
Error: Invalid number

$ cargo run -- 10
Error: Not enough arguments
```

---

## 🏗️ 実装の流れ

### ステップ1: プロジェクトの作成

```bash
cargo new calculator
cd calculator
```

### ステップ2: 演算子を表す列挙型の定義

```rust
enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
}
```

**C言語との違い:**
```c
// C言語: 単なる整数定数
enum Operator { ADD, SUB, MUL, DIV };

// Rust: 型として扱われ、パターンマッチで網羅性チェックされる
enum Operator { Add, Subtract, Multiply, Divide }
```

---

### ステップ3: 文字列から演算子への変換

まず、私が基本構造を用意します：

```rust
fn parse_operator(s: &str) -> Option<Operator> {
    match s {
        "+" => Some(Operator::Add),
        "-" => Some(Operator::Subtract),
        "*" => Some(Operator::Multiply),
        "/" => Some(Operator::Divide),
        _ => None,  // 不明な演算子の場合
    }
}
```

**重要ポイント:**
- `Option<T>`: 値があるかないかを表す型
  - `Some(値)`: 値がある
  - `None`: 値がない
- C言語のNULLとは異なり、**型システムで安全性を保証**

---

### ステップ4: 計算関数の実装

```rust
fn calculate(left: i32, op: Operator, right: i32) -> Option<i32> {
    match op {
        Operator::Add => Some(left + right),
        Operator::Subtract => Some(left - right),
        Operator::Multiply => Some(left * right),
        Operator::Divide => {
            if right == 0 {
                None  // ゼロ除算の場合はNone
            } else {
                Some(left / right)
            }
        }
    }
}
```

**matchの網羅性チェック:**
```rust
// もし Operator::Multiply を書き忘れたら
match op {
    Operator::Add => Some(left + right),
    Operator::Subtract => Some(left - right),
    // Operator::Multiply が抜けている
    Operator::Divide => { /* ... */ }
}
// コンパイルエラー！
// error[E0004]: non-exhaustive patterns: `Multiply` not covered
```

これがC言語の`switch`にはないRustの安全性です。

---

## ● Learn by Doing

**Context:** 基本的な関数は上記で準備しました。これから、コマンドライン引数を解析して計算を実行するメイン処理を実装します。これはRustプログラムの「入り口」となる重要な部分です。

**Your Task:** `src/main.rs` ファイルで、`main()` 関数を実装してください。以下の `TODO(human)` コメントがある部分を埋めてください。

**Guidance:**
- `std::env::args()` でコマンドライン引数を取得できます
- 引数は `Vec<String>` として `collect()` できます
- `args[0]` はプログラム名なので、実際の引数は `args[1]`, `args[2]`, `args[3]` です
- `parse::<i32>()` で文字列を整数に変換できます（失敗すると `Err` を返します）
- `match` で `Option` や `Result` の中身を取り出せます

```rust
use std::env;

enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
}

fn parse_operator(s: &str) -> Option<Operator> {
    match s {
        "+" => Some(Operator::Add),
        "-" => Some(Operator::Subtract),
        "*" => Some(Operator::Multiply),
        "/" => Some(Operator::Divide),
        _ => None,
    }
}

fn calculate(left: i32, op: Operator, right: i32) -> Option<i32> {
    match op {
        Operator::Add => Some(left + right),
        Operator::Subtract => Some(left - right),
        Operator::Multiply => Some(left * right),
        Operator::Divide => {
            if right == 0 {
                None
            } else {
                Some(left / right)
            }
        }
    }
}

fn main() {
    // TODO(human): コマンドライン引数を取得
    // ヒント: let args: Vec<String> = env::args().collect();

    // TODO(human): 引数の数をチェック（4個必要: プログラム名 + 3個の引数）
    // ヒント: if args.len() != 4 { ... }

    // TODO(human): 左辺の数値をパース
    // ヒント: let left = args[1].parse::<i32>();
    //         match で Ok/Err をチェック

    // TODO(human): 演算子をパース
    // ヒント: let op = parse_operator(&args[2]);
    //         match で Some/None をチェック

    // TODO(human): 右辺の数値をパース

    // TODO(human): 計算を実行
    // ヒント: let result = calculate(left, op, right);

    // TODO(human): 結果を出力
    // ヒント: match result {
    //             Some(value) => println!("{}", value),
    //             None => println!("Error: Division by zero"),
    //         }
}
```

---

## 💡 ヒント

### ヒント1: コマンドライン引数の取得

```rust
use std::env;

let args: Vec<String> = env::args().collect();
// args[0]: プログラム名（例: "target/debug/calculator"）
// args[1]: 第1引数（例: "10"）
// args[2]: 第2引数（例: "+"）
// args[3]: 第3引数（例: "20"）
```

### ヒント2: 引数の数チェック

```rust
if args.len() != 4 {
    println!("Error: Not enough arguments");
    println!("Usage: calculator <num1> <op> <num2>");
    return;  // main関数から早期リターン
}
```

### ヒント3: 文字列を数値に変換

```rust
let num_str = "42";
let num_result = num_str.parse::<i32>();  // Result<i32, ParseIntError>

match num_result {
    Ok(num) => println!("Number: {}", num),
    Err(_) => println!("Error: Invalid number"),
}

// または、値だけ取り出したい場合
let left = match args[1].parse::<i32>() {
    Ok(n) => n,
    Err(_) => {
        println!("Error: Invalid number");
        return;
    }
};
```

### ヒント4: Optionの扱い方

```rust
let op = parse_operator(&args[2]);

match op {
    Some(operator) => {
        // operatorを使って処理
    }
    None => {
        println!("Error: Unknown operator");
        return;
    }
}

// または、unwrap_orを使った簡潔な書き方（エラー処理が雑になるので非推奨）
// let op = parse_operator(&args[2]).unwrap();  // Noneだとパニック！
```

### ヒント5: 式とセミコロンの違い（重要！）

**Rustは式ベースの言語です：**

```rust
// セミコロンなし = 式（値を返す）
fn add_five(x: i32) -> i32 {
    x + 5  // ← セミコロンなし！これが戻り値
}

// セミコロンあり = 文（()を返す）
fn add_five_wrong(x: i32) -> i32 {
    x + 5;  // ← セミコロンあり！これは () を返す
    // コンパイルエラー！i32を返すべきなのに()を返している
}

// 明示的なreturn（Cスタイル）
fn add_five_explicit(x: i32) -> i32 {
    return x + 5;  // ← returnを使う場合はセミコロンあり
}
```

**matchも式です：**
```rust
let result = match calculate(left, op, right) {
    Some(value) => value,  // ← カンマ区切り、セミコロンではない
    None => {
        println!("Error: Division by zero");
        return;  // 早期リターン
    }
};
```

---

## ✅ テストケース

実装後、以下のテストケースで動作を確認してください：

```bash
# 正常系
cargo run -- 10 + 20          # => 30
cargo run -- 100 - 42         # => 58
cargo run -- 6 \* 7            # => 42
cargo run -- 100 / 5          # => 20
cargo run -- 7 / 2            # => 3 (整数除算)

# 異常系
cargo run -- 10 / 0           # => Error: Division by zero
cargo run -- 10 + abc         # => Error: Invalid number
cargo run -- 10               # => Error: Not enough arguments
cargo run --                  # => Error: Not enough arguments
cargo run -- 10 \& 20          # => Error: Unknown operator
```

---

## 📚 学習ポイントの解説

### enumとmatchの威力

**C言語との比較:**

```c
// C言語: defaultの書き忘れがバグの元
enum Operator { ADD, SUB, MUL, DIV };

int calculate(int left, enum Operator op, int right) {
    switch (op) {
        case ADD: return left + right;
        case SUB: return left - right;
        case MUL: return left * right;
        // DIVを書き忘れた！でもコンパイルは通る
        default: return 0;  // 想定外の値が来たら0？
    }
}
```

```rust
// Rust: すべてのケースを網羅しないとコンパイルエラー
fn calculate(left: i32, op: Operator, right: i32) -> Option<i32> {
    match op {
        Operator::Add => Some(left + right),
        Operator::Subtract => Some(left - right),
        Operator::Multiply => Some(left * right),
        // Divideを書き忘れたらコンパイルエラー！
    }
}
```

### Option vs NULL

**C言語:**
```c
int* divide(int a, int b) {
    if (b == 0) {
        return NULL;  // NULLチェック忘れがバグの元
    }
    int* result = malloc(sizeof(int));
    *result = a / b;
    return result;
}

// 使用側
int* result = divide(10, 2);
printf("%d\n", *result);  // NULLチェック忘れ！クラッシュの危険
free(result);
```

**Rust:**
```rust
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

// 使用側
let result = divide(10, 2);
// println!("{}", result);  // コンパイルエラー！Optionはそのまま表示できない
match result {  // 強制的にチェックさせられる
    Some(value) => println!("{}", value),
    None => println!("Error"),
}
```

### Result vs Option（次の課題で学ぶ）

今回は`Option`のみを使いましたが、次の課題では`Result`を学びます：

- **Option**: 値があるかないか（成功/失敗だけ）
- **Result**: 成功時の値とエラー情報の両方を持つ

---

## 🚀 発展課題

基本機能ができたら、以下の機能を追加してみましょう：

### レベル1: 浮動小数点数対応

```rust
// i32 を f64 に変更
fn calculate(left: f64, op: Operator, right: f64) -> Option<f64> {
    // ...
}
```

```bash
$ cargo run -- 10 / 3
3.3333333333333335
```

### レベル2: 剰余演算の追加

```rust
enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,  // ← 追加
}
```

```bash
$ cargo run -- 10 % 3
1
```

### レベル3: より親切なエラーメッセージ

```rust
Err(_) => {
    println!("Error: '{}' is not a valid number", args[1]);
    return;
}
```

---

## 🎓 完全な解答例

自分で実装してから見ることを強く推奨します！

> [!note]- 📝 完全な解答例を見る（実装後に確認）
>
> ```rust
> use std::env;
>
> enum Operator {
>     Add,
>     Subtract,
>     Multiply,
>     Divide,
> }
>
> fn parse_operator(s: &str) -> Option<Operator> {
>     match s {
>         "+" => Some(Operator::Add),
>         "-" => Some(Operator::Subtract),
>         "*" => Some(Operator::Multiply),
>         "/" => Some(Operator::Divide),
>         _ => None,
>     }
> }
>
> fn calculate(left: i32, op: Operator, right: i32) -> Option<i32> {
>     match op {
>         Operator::Add => Some(left + right),
>         Operator::Subtract => Some(left - right),
>         Operator::Multiply => Some(left * right),
>         Operator::Divide => {
>             if right == 0 {
>                 None
>             } else {
>                 Some(left / right)
>             }
>         }
>     }
> }
>
> fn main() {
>     // コマンドライン引数を取得
>     let args: Vec<String> = env::args().collect();
>
>     // 引数の数をチェック
>     if args.len() != 4 {
>         println!("Error: Not enough arguments");
>         println!("Usage: {} <number> <operator> <number>", args[0]);
>         println!("Example: {} 10 + 20", args[0]);
>         return;
>     }
>
>     // 左辺の数値をパース
>     let left = match args[1].parse::<i32>() {
>         Ok(n) => n,
>         Err(_) => {
>             println!("Error: Invalid number '{}'", args[1]);
>             return;
>         }
>     };
>
>     // 演算子をパース
>     let op = match parse_operator(&args[2]) {
>         Some(operator) => operator,
>         None => {
>             println!("Error: Unknown operator '{}'", args[2]);
>             println!("Supported operators: +, -, *, /");
>             return;
>         }
>     };
>
>     // 右辺の数値をパース
>     let right = match args[3].parse::<i32>() {
>         Ok(n) => n,
>         Err(_) => {
>             println!("Error: Invalid number '{}'", args[3]);
>             return;
>         }
>     };
>
>     // 計算を実行
>     let result = calculate(left, op, right);
>
>     // 結果を出力
>     match result {
>         Some(value) => println!("{}", value),
>         None => println!("Error: Division by zero"),
>     }
> }
> ```

---

## 🐛 よくあるエラーと解決法

### エラー1: "expected `i32`, found `()`"

```rust
fn add_five(x: i32) -> i32 {
    x + 5;  // ← セミコロンがあるとダメ！
}
```

**解決:** セミコロンを削除するか、`return`を使う

### エラー2: "cannot find value `args` in this scope"

```rust
fn main() {
    let result = args[1];  // argsが未定義！
}
```

**解決:** `use std::env;` と `let args: Vec<String> = env::args().collect();` を追加

### エラー3: "non-exhaustive patterns"

```rust
match op {
    Operator::Add => Some(left + right),
    // 他のケースが抜けている
}
```

**解決:** すべての`Operator`のケースを書く

---

## 🔗 関連資料

- [[01-メモリ管理の比較]] - 所有権の理解
- [[03-エラーハンドリング]] - Result型の詳細（次の課題で使います）
- [[04-構造体と列挙型]] - enumの活用
- [[デバッグガイド]] - エラーメッセージの読み方
- [The Rust Book: 列挙型とパターンマッチング](https://doc.rust-jp.rs/book-ja/ch06-00-enums.html)

---

## ✅ 完了チェックリスト

- [x] 基本的な四則演算が動作する
- [x] ゼロ除算のエラー処理ができている
- [x] 無効な数値入力のエラー処理ができている
- [x] 引数の個数チェックができている
- [x] `match`の網羅性チェックを体験した
- [x] 式とセミコロンの違いを理解した
- [x] `cargo clippy` で警告が出ない
- [x] すべてのテストケースが通る

完了したら、[[00-学習進捗チェックリスト]]にチェックを入れましょう！

---

[[課題02-文字列操作ツール|次の課題: 文字列操作ツール →]]
