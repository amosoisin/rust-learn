# 課題02: 文字列操作ツール

[[課題01-計算機プログラム|← 前の課題]]  |  [[README|トップに戻る]]  |  [[課題03-CSVパーサー|次の課題 →]]

**難易度:** ⭐️⭐️
**学習時間目安:** 3-4時間
**学習トピック:** String vs &str、所有権、借用、ベクタ、イテレータ

---

## 🎯 課題の目的

Rustの文字列型（`String`と`&str`）の違いと、所有権システムを理解するための文字列操作ツールを作成します。

### 学ぶこと
- **`String` vs `&str` の違い**（最重要）
- 所有権とムーブ
- 借用と参照（`&`）
- ベクタ（`Vec<T>`）の使用
- イテレータの基本（`lines()`, `split_whitespace()`）
- 関数の引数に`&str`を使うべき理由

---

## 📋 仕様

テキストファイルを読み込み、様々な文字列操作を行うCLIツールを作成してください。

### 基本コマンド

```bash
# 単語数をカウント
$ cargo run -- count sample.txt
Words: 24
Lines: 5
Characters: 155

# すべて大文字に変換
$ cargo run -- upper sample.txt
HELLO WORLD
RUST IS A SYSTEMS PROGRAMMING LANGUAGE.
...

# すべて小文字に変換
$ cargo run -- lower sample.txt
hello world
rust is a systems programming language.
...

# 特定の単語を検索（大文字小文字を区別しない）
$ cargo run -- search sample.txt "rust"
Found 'rust' on line 2: Rust is a systems programming language.
Found 'rust' on line 4: Learning Rust is fun!
Found 'rust' on line 5: Say hello to Rust programming.
```

---

## 🏗️ 実装の流れ

### ステップ1: プロジェクトの作成

```bash
cargo new text_tool
cd text_tool
```

### ステップ2: サンプルファイルの作成

`sample.txt` を作成:
```text
Hello World
Rust is a systems programming language.
It is fast and memory-safe.
Learning Rust is fun!
Say hello to Rust programming.
```

---

### ステップ3: String vs &str の理解（超重要！）

Rustには2種類の文字列型があります。これを理解することが、Rust習得の鍵です。

#### &str（文字列スライス）- 借用された文字列

```rust
// 文字列リテラルは &str
let greeting: &str = "Hello";

// String からスライスを取得
let owned = String::from("Hello, World!");
let slice: &str = &owned[0..5];  // "Hello"
```

**特徴:**
- **不変**（変更できない）
- **借用**されたデータへの参照
- スタック上のポインタとサイズだけ（16バイト固定）
- コピーが安い

**C言語との対比:**
```c
// C言語の文字列リテラル（読み取り専用メモリ領域）
const char *s = "Hello";  // .rodataセグメントを指すポインタ
```

#### String（所有された文字列）- ヒープ上の文字列

```rust
// String::from で作成
let s = String::from("Hello");

// to_string() メソッド
let s = "Hello".to_string();

// 変更可能
let mut s = String::from("Hello");
s.push_str(", World!");  // "Hello, World!"
```

**特徴:**
- **可変**（変更できる）
- **所有権**を持つ
- ヒープ上にデータを持つ
- 伸縮可能（`push_str`, `push`など）

**C言語との対比:**
```c
// C言語のヒープ上の文字列バッファ
char *s = malloc(100);
strcpy(s, "Hello");
strcat(s, ", World!");
free(s);  // 手動解放が必要
```

```rust
// Rust
let mut s = String::from("Hello");
s.push_str(", World!");
// スコープを抜けると自動解放
```

---

### ステップ4: 関数引数に &str を使う理由

**悪い例:**
```rust
fn print_text(s: &String) {  // ❌ 柔軟性が低い
    println!("{}", s);
}

fn main() {
    let string = String::from("hello");
    print_text(&string);  // OK

    let literal = "world";
    // print_text(literal);  // コンパイルエラー！&Stringが必要
}
```

**良い例:**
```rust
fn print_text(s: &str) {  // ✅ 柔軟
    println!("{}", s);
}

fn main() {
    let string = String::from("hello");
    print_text(&string);  // &Stringは自動的に&strに変換される（deref coercion）

    let literal = "world";
    print_text(literal);  // &strなのでそのまま渡せる
}
```

**ベストプラクティス:** 関数の引数には `&str` を使う（より汎用的）

---

## ● Learn by Doing

**Context:** 私が基本的なmain関数の骨組みを用意しました。これから、実際の文字列操作を行う関数を実装します。イテレータや文字列メソッドを使って、Rustの関数型プログラミング的なアプローチに慣れましょう。

**Your Task:** 以下の関数を`src/main.rs`に実装してください。`TODO(human)`の部分を埋めてください。

**Guidance:**
- `text.lines()` で行ごとのイテレータを取得
- `text.split_whitespace()` で単語ごとに分割
- `text.chars()` で文字ごとのイテレータを取得
- `.count()` でイテレータの要素数を数える
- `to_lowercase()` / `to_uppercase()` で大文字小文字変換
- `contains()` で部分文字列を検索
- `enumerate()` で行番号付きのイテレータを取得

```rust
use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 3 {
        eprintln!("Usage: text_tool <command> <filename> [query]");
        eprintln!("Commands: count, upper, lower, search");
        process::exit(1);
    }

    let command = &args[1];
    let filename = &args[2];

    let contents = match read_file(filename) {
        Ok(text) => text,
        Err(e) => {
            eprintln!("Error reading file: {}", e);
            process::exit(1);
        }
    };

    match command.as_str() {
        "count" => {
            let (words, lines, chars) = count_words(&contents);
            println!("Words: {}", words);
            println!("Lines: {}", lines);
            println!("Characters: {}", chars);
        }
        "upper" => {
            println!("{}", to_upper(&contents));
        }
        "lower" => {
            println!("{}", to_lower(&contents));
        }
        "search" => {
            if args.len() < 4 {
                eprintln!("Error: search requires a query");
                process::exit(1);
            }
            let query = &args[3];
            let results = search(&contents, query);

            for (line_num, line) in results {
                println!("Found '{}' on line {}: {}", query, line_num, line);
            }
        }
        _ => {
            eprintln!("Unknown command: {}", command);
            process::exit(1);
        }
    }
}

// この関数は実装済み
fn read_file(filename: &str) -> Result<String, std::io::Error> {
    fs::read_to_string(filename)
}

// TODO(human): 単語数、行数、文字数をカウントする関数を実装
// ヒント:
// - let lines = text.lines().count();
// - let words = text.split_whitespace().count();
// - let chars = text.chars().count();
fn count_words(text: &str) -> (usize, usize, usize) {
    todo!()
}

// TODO(human): すべて大文字に変換する関数を実装
// ヒント: text.to_uppercase() を使う
fn to_upper(text: &str) -> String {
    todo!()
}

// TODO(human): すべて小文字に変換する関数を実装
// ヒント: text.to_lowercase() を使う
fn to_lower(text: &str) -> String {
    todo!()
}

// TODO(human): クエリ文字列を含む行を検索する関数を実装
// ヒント:
// 1. let mut results = Vec::new(); で結果を格納するベクタを作成
// 2. text.lines().enumerate() で行番号付きのイテレータを取得
// 3. line.to_lowercase().contains(&query.to_lowercase()) で大文字小文字を無視して検索
//    ただし、効率のため query.to_lowercase() はループの外で一度だけ実行すべき
// 4. 見つかったら results.push((i + 1, line.to_string()));
// 5. results を返す
fn search(text: &str, query: &str) -> Vec<(usize, String)> {
    todo!()
}
```

---

## 💡 ヒント

### ヒント1: count_words の実装

```rust
fn count_words(text: &str) -> (usize, usize, usize) {
    let lines = text.lines().count();
    let words = text.split_whitespace().count();
    let chars = text.chars().count();

    (words, lines, chars)  // タプルで返す
}
```

**イテレータの便利さ:**
```c
// C言語なら面倒なループが必要
int count_lines(const char *text) {
    int count = 0;
    for (int i = 0; text[i] != '\0'; i++) {
        if (text[i] == '\n') count++;
    }
    return count;
}
```

```rust
// Rustならワンライナー
let lines = text.lines().count();
```

### ヒント2: to_upper と to_lower

```rust
fn to_upper(text: &str) -> String {
    text.to_uppercase()  // 新しいStringを返す
}

fn to_lower(text: &str) -> String {
    text.to_lowercase()
}
```

**重要:** `to_uppercase()` は新しい`String`を作成します（元の`&str`は不変なので）。

### ヒント3: search 関数（効率的な実装）

```rust
fn search(text: &str, query: &str) -> Vec<(usize, String)> {
    let mut results = Vec::new();
    let query_lower = query.to_lowercase();  // ← 一度だけ小文字化（重要！）

    for (i, line) in text.lines().enumerate() {
        if line.to_lowercase().contains(&query_lower) {
            results.push((i + 1, line.to_string()));
        }
    }

    results
}
```

**非効率な実装（避けるべき）:**
```rust
// ❌ 毎回 query.to_lowercase() を呼ぶと無駄
if line.to_lowercase().contains(&query.to_lowercase()) {
    // query.to_lowercase() がループ内で毎回実行される
}
```

### ヒント4: 所有権とムーブ

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1の所有権がs2に「ムーブ」される

    // println!("{}", s1);  // コンパイルエラー！s1はもう無効
    println!("{}", s2);  // OK
}
```

**C言語との違い:**
```c
char *s1 = malloc(100);
strcpy(s1, "hello");
char *s2 = s1;  // ポインタをコピー（浅いコピー）

printf("%s\n", s1);  // OK（危険だが動く）
printf("%s\n", s2);  // OK

free(s1);
// s2は今ダングリングポインタ（use-after-free）
```

### ヒント5: 借用

```rust
fn print_length(s: &String) {  // 借用（所有権は移動しない）
    println!("Length: {}", s.len());
}

fn main() {
    let s = String::from("hello");
    print_length(&s);  // 参照を渡す
    println!("{}", s);  // sはまだ有効
}
```

---

## ✅ テストケース

実装後、以下のテストケースで動作を確認してください：

```bash
# カウント
$ cargo run -- count sample.txt
Words: 24
Lines: 5
Characters: 155

# 大文字変換
$ cargo run -- upper sample.txt
HELLO WORLD
RUST IS A SYSTEMS PROGRAMMING LANGUAGE.
IT IS FAST AND MEMORY-SAFE.
LEARNING RUST IS FUN!
SAY HELLO TO RUST PROGRAMMING.

# 小文字変換
$ cargo run -- lower sample.txt
hello world
rust is a systems programming language.
...

# 検索
$ cargo run -- search sample.txt "rust"
Found 'rust' on line 2: Rust is a systems programming language.
Found 'rust' on line 4: Learning Rust is fun!
Found 'rust' on line 5: Say hello to Rust programming.

$ cargo run -- search sample.txt "hello"
Found 'hello' on line 1: Hello World
Found 'hello' on line 5: Say hello to Rust programming.
```

---

## 📚 学習ポイントの解説

### メモリレイアウト（視覚的理解）

```
Stack（スタック）:
┌──────────────────┐
│ s: &str          │ ← "Hello"を指すポインタ（8バイト）+ 長さ（8バイト）= 16バイト
│  ├─ ptr: 0x1000 │
│  └─ len: 5      │
└──────────────────┘

Heap（ヒープ）: なし（文字列リテラルは.rodataセグメント）


String の場合:
Stack:
┌──────────────────┐
│ s: String        │
│  ├─ ptr: 0x2000 │ ← ヒープを指す
│  ├─ len: 5      │
│  └─ cap: 10     │ ← 容量
└──────────────────┘
        │
        v
Heap:
┌──────────────────┐
│ 'H' 'e' 'l' 'l' 'o' ... │ ← 実際のデータ
└──────────────────┘
```

### String vs &str の使い分け

| 状況 | 使うべき型 | 理由 |
|------|------------|------|
| 関数の引数 | `&str` | 柔軟性が高い |
| 関数の戻り値（新規作成） | `String` | 所有権を渡す |
| 関数の戻り値（参照） | `&str` | 借用のまま返す |
| 変更が必要 | `String` | 可変 |
| 変更不要 | `&str` | 効率的 |

---

## 🚀 発展課題

### レベル1: 統計情報の追加

```rust
fn statistics(text: &str) {
    let (words, lines, chars) = count_words(text);

    // TODO: 平均単語長を計算
    let total_word_len: usize = text.split_whitespace()
        .map(|word| word.len())
        .sum();
    let avg_word_length = total_word_len as f64 / words as f64;

    // TODO: 最長の単語を見つける
    let longest_word = text.split_whitespace()
        .max_by_key(|word| word.len())
        .unwrap_or("");

    println!("Average word length: {:.2}", avg_word_length);
    println!("Longest word: {}", longest_word);
}
```

### レベル2: 文字列置換

```bash
$ cargo run -- replace sample.txt "Rust" "Python"
```

### レベル3: 正規表現検索

```toml
# Cargo.toml
[dependencies]
regex = "1"
```

### レベル4: ファイル出力

```bash
$ cargo run -- upper sample.txt --output output.txt
Converted text written to output.txt
```

---

## 🎓 完全な解答例

自分で実装してから見ることを強く推奨します！

> [!note]- 📝 完全な解答例を見る（実装後に確認）
>
> ```rust
> use std::env;
> use std::fs;
> use std::process;
>
> fn main() {
>     let args: Vec<String> = env::args().collect();
>
>     if args.len() < 3 {
>         eprintln!("Usage: text_tool <command> <filename> [query]");
>         eprintln!("Commands: count, upper, lower, search");
>         process::exit(1);
>     }
>
>     let command = &args[1];
>     let filename = &args[2];
>
>     let contents = match read_file(filename) {
>         Ok(text) => text,
>         Err(e) => {
>             eprintln!("Error reading file: {}", e);
>             process::exit(1);
>         }
>     };
>
>     match command.as_str() {
>         "count" => {
>             let (words, lines, chars) = count_words(&contents);
>             println!("Words: {}", words);
>             println!("Lines: {}", lines);
>             println!("Characters: {}", chars);
>         }
>         "upper" => {
>             println!("{}", to_upper(&contents));
>         }
>         "lower" => {
>             println!("{}", to_lower(&contents));
>         }
>         "search" => {
>             if args.len() < 4 {
>                 eprintln!("Error: search requires a query");
>                 process::exit(1);
>             }
>             let query = &args[3];
>             let results = search(&contents, query);
>
>             for (line_num, line) in results {
>                 println!("Found '{}' on line {}: {}", query, line_num, line);
>             }
>         }
>         _ => {
>             eprintln!("Unknown command: {}", command);
>             process::exit(1);
>         }
>     }
> }
>
> fn read_file(filename: &str) -> Result<String, std::io::Error> {
>     fs::read_to_string(filename)
> }
>
> fn count_words(text: &str) -> (usize, usize, usize) {
>     let lines = text.lines().count();
>     let words = text.split_whitespace().count();
>     let chars = text.chars().count();
>
>     (words, lines, chars)
> }
>
> fn to_upper(text: &str) -> String {
>     text.to_uppercase()
> }
>
> fn to_lower(text: &str) -> String {
>     text.to_lowercase()
> }
>
> fn search(text: &str, query: &str) -> Vec<(usize, String)> {
>     let mut results = Vec::new();
>     let query_lower = query.to_lowercase();
>
>     for (i, line) in text.lines().enumerate() {
>         if line.to_lowercase().contains(&query_lower) {
>             results.push((i + 1, line.to_string()));
>         }
>     }
>
>     results
> }
> ```

---

## 🐛 よくあるエラーと解決法

### エラー1: "cannot find value `todo` in this scope"

```rust
fn count_words(text: &str) -> (usize, usize, usize) {
    todo!()  // ← これを実装する必要がある
}
```

**解決:** `todo!()` を実際のコードに置き換える

### エラー2: "mismatched types: expected `(usize, usize, usize)`, found `usize`"

```rust
fn count_words(text: &str) -> (usize, usize, usize) {
    text.lines().count()  // ← usizeを1つしか返していない
}
```

**解決:** タプルで3つの値を返す

```rust
fn count_words(text: &str) -> (usize, usize, usize) {
    let lines = text.lines().count();
    let words = text.split_whitespace().count();
    let chars = text.chars().count();
    (words, lines, chars)  // ← タプル
}
```

### エラー3: "borrow of moved value: `s`"

```rust
let s = String::from("hello");
let s2 = s;  // sの所有権がs2に移動
println!("{}", s);  // エラー！sはもう使えない
```

**解決:** クローンするか、借用を使う

```rust
let s = String::from("hello");
let s2 = s.clone();  // クローン
println!("{}, {}", s, s2);  // 両方OK
```

---

## 🔗 関連資料

- [[01-メモリ管理の比較]] - 所有権システムの詳細
- [[02-ポインタと参照・借用]] - 借用ルールの深掘り
- [[デバッグガイド]] - エラーメッセージの読み方
- [The Rust Book: 文字列](https://doc.rust-jp.rs/book-ja/ch08-02-strings.html)

---

## ✅ 完了チェックリスト

- [ ] `String` と `&str` の違いを理解した
- [ ] 所有権とムーブの概念を理解した
- [ ] 借用と参照の使い方を理解した
- [ ] イテレータの基本的な使い方を習得した
- [ ] すべての基本コマンドが動作する
- [ ] `cargo clippy` で警告が出ない
- [ ] 発展課題に1つ以上チャレンジした

完了したら、[[00-学習進捗チェックリスト]]にチェックを入れましょう！

---

[[課題03-CSVパーサー|次の課題: CSVパーサー →]]
