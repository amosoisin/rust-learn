# メモリ管理の比較

[[README|← トップに戻る]]  |  [[02-ポインタと参照・借用|次: ポインタと参照・借用 →]]

---

## 概要

C言語とRustの最も大きな違いは、**メモリ安全性の保証方法**です。C言語では実行時に問題が発生するメモリエラーを、Rustはコンパイル時に検出します。

---

## C言語のメモリ管理

### 手動メモリ管理

```c
#include <stdlib.h>
#include <string.h>

void example() {
    // ヒープメモリの確保
    char *buffer = malloc(100);
    if (buffer == NULL) {
        // エラーハンドリング
        return;
    }

    strcpy(buffer, "Hello, World!");

    // 使用後は手動で解放
    free(buffer);
    // buffer は今ダングリングポインタ
}
```

### C言語の問題点

1. **メモリリーク** - `free()` を忘れる
   ```c
   char *data = malloc(100);
   // ... 処理 ...
   // free() を忘れた！
   return; // メモリリーク
   ```

2. **ダングリングポインタ** - 解放後のメモリにアクセス
   ```c
   char *ptr = malloc(100);
   free(ptr);
   strcpy(ptr, "危険!"); // use-after-free バグ
   ```

3. **二重解放** - 同じメモリを2回解放
   ```c
   char *ptr = malloc(100);
   free(ptr);
   free(ptr); // 二重解放 - クラッシュの原因
   ```

4. **バッファオーバーフロー**
   ```c
   char buffer[10];
   strcpy(buffer, "This is too long!"); // バッファオーバーフロー
   ```

---

## Rustの所有権システム

### 所有権の3つのルール

1. **各値には所有者（owner）が1つだけ存在する**
2. **所有者は同時に1つだけ**
3. **所有者がスコープを抜けると、値は自動的に破棄される**

### 基本例

```rust
fn example() {
    // String型はヒープメモリを使用
    let s = String::from("Hello, World!");

    // s を使用
    println!("{}", s);

    // スコープを抜けると自動的にメモリが解放される
} // ← ここで s が Drop され、メモリが解放される
```

### ムーブセマンティクス

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 の所有権が s2 に「ムーブ」される

    // println!("{}", s1); // コンパイルエラー！s1 はもう無効
    println!("{}", s2); // OK
}
```

**メモリレイアウトで見る所有権の移動:**

```
ムーブ前（let s1 = String::from("hello");）:

スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1:             │          │               │
│  ├─ ptr ────────┼─────────>│ h e l l o \0  │
│  ├─ len: 5      │          │               │
│  └─ cap: 5      │          └───────────────┘
└─────────────────┘

ムーブ後（let s2 = s1;）:

スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1: [無効]      │    ╱────>│ h e l l o \0  │
├─────────────────┤   ╱       │               │
│ s2:             │  ╱        └───────────────┘
│  ├─ ptr ────────┼─┘
│  ├─ len: 5      │
│  └─ cap: 5      │
└─────────────────┘

ポイント:
- スタック上のポインタ情報（ptr, len, cap）がs2にコピーされる
- ヒープのデータ自体はコピーされない（高速！）
- s1は無効になり、使えなくなる（二重解放を防ぐ）
```

**C言語との対比:**
```c
char *s1 = malloc(100);
strcpy(s1, "hello");
char *s2 = s1; // ポインタをコピー（浅いコピー）

printf("%s\n", s1); // OK（危険だが動く）
printf("%s\n", s2); // OK

free(s1);
// s2 は今ダングリングポインタ
```

**C言語のメモリレイアウト（危険！）:**

```
スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1 ─────────────┼─────────>│ h e l l o \0  │
├─────────────────┤    ┌─────>│               │
│ s2 ─────────────┼────┘      └───────────────┘
└─────────────────┘

問題点:
- s1とs2が同じヒープメモリを指す
- free(s1) すると s2 がダングリングポインタになる
- free(s2) すると二重解放エラー
- コンパイラは検出できない！
```

### クローン（明示的なコピー）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 明示的にヒープデータをコピー

    println!("{}", s1); // OK
    println!("{}", s2); // OK
}
```

**メモリレイアウトで見るクローン:**

```
クローン後（let s2 = s1.clone();）:

スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1:             │          │               │
│  ├─ ptr ────────┼─────────>│ h e l l o \0  │
│  ├─ len: 5      │          │               │
│  └─ cap: 5      │          └───────────────┘
├─────────────────┤          ┌───────────────┐
│ s2:             │          │               │
│  ├─ ptr ────────┼─────────>│ h e l l o \0  │
│  ├─ len: 5      │          │               │
│  └─ cap: 5      │          └───────────────┘
└─────────────────┘

ポイント:
- ヒープ上のデータが完全にコピーされる（深いコピー）
- s1とs2は独立したメモリを所有
- どちらもスコープを抜けると個別に解放される
- コストが高い（明示的に.clone()を書く必要がある）
```

**C言語との対比:**
```c
char *s1 = malloc(100);
strcpy(s1, "hello");

// 明示的な深いコピー
char *s2 = malloc(100);
strcpy(s2, s1);

free(s1);
free(s2); // 両方を個別に解放する必要がある
```

**C言語のメモリレイアウト:**

```
スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1 ─────────────┼─────────>│ h e l l o \0  │
├─────────────────┤          └───────────────┘
│ s2 ─────────────┼────┐     ┌───────────────┐
└─────────────────┘    └────>│ h e l l o \0  │
                              └───────────────┘

注意:
- Rustと同じく独立したメモリ
- ただし free() を忘れるとメモリリーク
- バッファサイズの管理が必要（strcpyは危険）
```

---

## スタックとヒープの扱い

### C言語

```c
void stack_example() {
    int x = 5;           // スタック
    int *y = malloc(4);  // ヒープ
    *y = 10;

    free(y); // ヒープは手動解放
    // スタック（x）は自動的に解放される
}
```

**C言語のメモリレイアウト:**

```
スタック:                     ヒープ:
┌─────────────────┐          ┌───────┐
│ x: 5            │          │       │
├─────────────────┤          │  10   │
│ y ──────────────┼─────────>│       │
└─────────────────┘          └───────┘

関数終了時:
- x は自動的に解放される
- y（ポインタ）は自動的に解放される
- ヒープのデータは free() しないと残る（メモリリーク）
```

### Rust

```rust
fn stack_example() {
    let x = 5;                    // スタック（i32はCopy）
    let y = Box::new(10);         // ヒープ（Box<i32>）

    // y はスコープを抜けると自動的に解放される
    // x もスコープを抜けると消える
}
```

**Rustのメモリレイアウト:**

```
スタック:                     ヒープ:
┌─────────────────┐          ┌───────┐
│ x: 5            │          │       │
├─────────────────┤          │  10   │
│ y ──────────────┼─────────>│       │
└─────────────────┘          └───────┘

関数終了時（スコープを抜ける）:
- x は自動的に解放される（Copy型）
- y は自動的に解放される
- y が所有するヒープデータも自動的に解放される（Drop トレイト）
→ メモリリークが起こらない！
```

**★ スタック vs ヒープ**

| 特性 | スタック | ヒープ |
|------|----------|--------|
| **速度** | 高速（ポインタを動かすだけ） | 低速（メモリアロケータが探す） |
| **サイズ** | 固定サイズ（コンパイル時に決定） | 動的サイズ（実行時に決定） |
| **寿命** | 関数スコープ | 明示的に管理 |
| **Rust の型例** | `i32`, `f64`, `bool`, `[i32; 5]` | `String`, `Vec<T>`, `Box<T>` |

---

## Copy vs Move

### C言語の基本型（常にコピー）

```c
int x = 5;
int y = x; // コピー
x = 10;
printf("%d, %d\n", x, y); // 10, 5
```

### Rustの基本型（Copy トレイト）

```rust
fn main() {
    let x = 5;
    let y = x; // コピー（i32 は Copy トレイト実装済み）
    let z = x; // x はまだ有効

    println!("{}, {}, {}", x, y, z); // 5, 5, 5
}
```

**Copy型のメモリレイアウト（i32の例）:**

```
すべてスタック上:
┌─────────────────┐
│ x: 5            │
├─────────────────┤
│ y: 5            │  ← x の値がコピーされる（ビット単位のコピー）
├─────────────────┤
│ z: 5            │  ← x の値がコピーされる
└─────────────────┘

ポイント:
- すべてスタック上で完結（ヒープを使わない）
- ビット単位の浅いコピー
- 高速（メモリアロケーションなし）
- x, y, z は独立した値
```

**Move型のメモリレイアウト（Stringの例）:**

```
スタック:                     ヒープ:
┌─────────────────┐          ┌───────────────┐
│ s1: [無効]      │    ╱────>│ h e l l o \0  │
├─────────────────┤   ╱       │               │
│ s2:             │  ╱        └───────────────┘
│  ├─ ptr ────────┼─┘
│  ├─ len: 5      │
│  └─ cap: 5      │
└─────────────────┘

ポイント:
- ヒープを使う型は Move される
- ポインタ情報だけがコピーされる（浅いコピー）
- 元の変数（s1）は無効になる
- 二重解放を防ぐ仕組み
```

**Copy トレイトを持つ型:**
- すべての整数型（`i32`, `u64`, etc.）
- 浮動小数点型（`f32`, `f64`）
- `bool`
- `char`
- タプル（全要素がCopy可能な場合）
- 固定サイズ配列（`[T; N]` で T が Copy の場合）

**Copy トレイトを持たない型（ムーブされる）:**
- `String`（ヒープにデータを持つ）
- `Vec<T>`（ヒープにデータを持つ）
- `Box<T>`（ヒープにデータを持つ）
- その他ヒープアロケーションする型

**★ なぜ Copy と Move が分かれているのか？**

```
Copy型（スタック上）:
- コピーコストが低い（数バイト）
- コピーしても問題ない
例: i32（4バイト）、bool（1バイト）

Move型（ヒープを使う）:
- コピーコストが高い可能性
- 所有権を明確にする必要
例: String（数MB のデータかもしれない）
     Vec<T>（巨大な配列かもしれない）
```

---

## メモリ安全性の保証

### C言語 - 実行時エラー

```c
char *dangerous() {
    char buffer[100] = "local data";
    return buffer; // ダングリングポインタを返す！
}

int main() {
    char *ptr = dangerous();
    printf("%s\n", ptr); // 未定義動作
}
```

### Rust - コンパイルエラー

```rust
fn dangerous() -> &str {
    let s = String::from("local data");
    &s // コンパイルエラー！ローカル変数への参照を返そうとしている
}
```

コンパイラのエラーメッセージ:
```
error[E0515]: cannot return reference to local variable `s`
  --> src/main.rs:3:5
   |
3  |     &s
   |     ^^ returns a reference to data owned by the current function
```

---

## 実践例: 動的配列

### C言語

```c
#include <stdlib.h>
#include <string.h>

typedef struct {
    char **items;
    size_t len;
    size_t capacity;
} Vector;

Vector* vec_new() {
    Vector *v = malloc(sizeof(Vector));
    v->items = malloc(10 * sizeof(char*));
    v->len = 0;
    v->capacity = 10;
    return v;
}

void vec_push(Vector *v, const char *item) {
    if (v->len >= v->capacity) {
        v->capacity *= 2;
        v->items = realloc(v->items, v->capacity * sizeof(char*));
    }
    v->items[v->len++] = strdup(item);
}

void vec_free(Vector *v) {
    for (size_t i = 0; i < v->len; i++) {
        free(v->items[i]);
    }
    free(v->items);
    free(v);
}

int main() {
    Vector *v = vec_new();
    vec_push(v, "hello");
    vec_push(v, "world");

    // 使用...

    vec_free(v); // 忘れるとメモリリーク
}
```

### Rust

```rust
fn main() {
    let mut v = Vec::new(); // ヒープアロケーション
    v.push("hello");
    v.push("world");

    // 使用...

    // スコープを抜けると自動的に解放
}
```

---

## まとめ

| 項目 | C言語 | Rust |
|------|-------|------|
| **メモリ解放** | 手動（`free()`） | 自動（スコープを抜けると解放） |
| **エラー検出** | 実行時（クラッシュやUB） | コンパイル時 |
| **所有権** | なし（自己管理） | 厳格なルール |
| **メモリリーク** | 起こりやすい | ほぼ不可能（意図的でない限り） |
| **ダングリングポインタ** | 起こりやすい | コンパイラが防ぐ |
| **二重解放** | 起こりやすい | コンパイラが防ぐ |
| **学習曲線** | 緩やか | 急（所有権の理解が必要） |
| **実行時オーバーヘッド** | なし | ほぼなし（ゼロコスト抽象化） |

---

## 重要なポイント

### C言語経験者への助言

1. **「誰がメモリを所有しているか」を常に意識する**
   - C言語: プログラマの頭の中で管理
   - Rust: コンパイラが強制

2. **RAIIパターンの徹底**
   - C言語: リソース管理は慣習
   - Rust: 言語機能として組み込み済み

3. **型システムを活用する**
   - `Box<T>`: ヒープ上の単一の値
   - `Vec<T>`: 動的配列
   - `String`: 所有権を持つ文字列

4. **コンパイラを味方にする**
   - エラーメッセージは詳しく、解決策を提示してくれる
   - 最初は厳しく感じるが、実行時バグが激減する

---

## 次のステップ

- [[02-ポインタと参照・借用]] - Rustの参照システムを学ぶ
- [[課題01-計算機プログラム]] - 所有権を意識しながらコードを書く
- [[課題02-文字列操作ツール]] - String vs &str の違いを体感

---

**関連リンク:**
- [The Rust Book: 所有権](https://doc.rust-jp.rs/book-ja/ch04-00-understanding-ownership.html)
- [Rust by Example: Ownership](https://doc.rust-jp.rs/rust-by-example-ja/scope/move.html)
