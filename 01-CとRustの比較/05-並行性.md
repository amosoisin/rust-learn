# 並行性

[[04-構造体と列挙型|← 前: 構造体と列挙型]]  |  [[README|トップに戻る]]

---

## 概要

並行プログラミングはバグが発生しやすい領域です。C言語のpthreadsは柔軟ですが危険が伴います。Rustは所有権システムにより、コンパイル時にデータ競合を防ぎます。

---

## C言語 - pthreads

### 基本的なスレッド作成

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *thread_function(void *arg) {
    int *num = (int *)arg;
    printf("Thread %d running\n", *num);
    sleep(1);
    printf("Thread %d done\n", *num);
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    int n1 = 1, n2 = 2;

    pthread_create(&thread1, NULL, thread_function, &n1);
    pthread_create(&thread2, NULL, thread_function, &n2);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
```

**問題点:**
- 型安全性なし（`void*`の使用）
- データ競合の検出なし
- エラーハンドリングが煩雑

---

## Rust - std::thread

### 基本的なスレッド作成

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle1 = thread::spawn(|| {
        println!("Thread 1 running");
        thread::sleep(Duration::from_secs(1));
        println!("Thread 1 done");
    });

    let handle2 = thread::spawn(|| {
        println!("Thread 2 running");
        thread::sleep(Duration::from_secs(1));
        println!("Thread 2 done");
    });

    handle1.join().unwrap();
    handle2.join().unwrap();
}
```

**利点:**
- 型安全
- クロージャによる簡潔な記述
- 所有権システムによる安全性

---

## データ競合の防止

### C言語 - ミューテックス（手動管理）

```c
#include <pthread.h>
#include <stdio.h>

int counter = 0;
pthread_mutex_t mutex;

void *increment(void *arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;  // クリティカルセクション
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&mutex, NULL);

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Counter: %d\n", counter);  // 200000 になるはず

    pthread_mutex_destroy(&mutex);
    return 0;
}
```

**よくあるバグ:**
```c
// ロック忘れ
counter++;  // データ競合！

// アンロック忘れ
pthread_mutex_lock(&mutex);
if (error) {
    return NULL;  // デッドロック！
}
pthread_mutex_unlock(&mutex);
```

### Rust - Mutex<T>（型で保証）

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..2 {
        handles.push(thread::spawn(|| {
            for _ in 0..100000 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }  // ← ここで自動的にアンロック
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Counter: {}", *counter.lock().unwrap());
}
```

**コンパイルエラーになる理由:**
```
error[E0373]: closure may outlive the current function
```

Rustは`counter`がスレッド間で共有されることを検出し、エラーを出します。

---

## Arc - スレッド間でのデータ共有

### C言語 - グローバル変数（危険）

```c
int shared_data = 0;  // グローバル変数

void *reader(void *arg) {
    printf("Data: %d\n", shared_data);
    return NULL;
}

void *writer(void *arg) {
    shared_data = 42;  // データ競合の可能性
    return NULL;
}
```

### Rust - Arc<Mutex<T>>

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);  // 参照カウントを増やす
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

**Arc の説明:**
- `Arc` = Atomic Reference Counted（アトミックな参照カウント）
- スレッド間で安全にデータを共有
- 参照カウントが0になると自動的に解放

---

## Send と Sync トレイト

### Rustのスレッド安全性の保証

```rust
// Send: 所有権をスレッド間で移動できる
// Sync: 不変参照をスレッド間で共有できる

fn is_send<T: Send>() {}
fn is_sync<T: Sync>() {}

fn main() {
    is_send::<i32>();      // OK
    is_send::<String>();   // OK
    is_sync::<i32>();      // OK

    // is_send::<Rc<i32>>(); // コンパイルエラー（Rcはスレッドセーフでない）
    is_send::<Arc<i32>>(); // OK（ArcはSend）
}
```

**C言語との違い:**
- C言語: プログラマが手動でスレッド安全性を管理
- Rust: 型システムがスレッド安全性を保証

---

## チャネル - スレッド間通信

### C言語 - パイプまたはキュー（複雑）

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *buffer;
    int size;
    int count;
    int in;
    int out;
    pthread_mutex_t mutex;
    pthread_cond_t not_empty;
    pthread_cond_t not_full;
} Queue;

void queue_init(Queue *q, int size) {
    q->buffer = malloc(size * sizeof(int));
    q->size = size;
    q->count = 0;
    q->in = 0;
    q->out = 0;
    pthread_mutex_init(&q->mutex, NULL);
    pthread_cond_init(&q->not_empty, NULL);
    pthread_cond_init(&q->not_full, NULL);
}

void queue_push(Queue *q, int value) {
    pthread_mutex_lock(&q->mutex);

    while (q->count == q->size) {
        pthread_cond_wait(&q->not_full, &q->mutex);
    }

    q->buffer[q->in] = value;
    q->in = (q->in + 1) % q->size;
    q->count++;

    pthread_cond_signal(&q->not_empty);
    pthread_mutex_unlock(&q->mutex);
}

int queue_pop(Queue *q) {
    pthread_mutex_lock(&q->mutex);

    while (q->count == 0) {
        pthread_cond_wait(&q->not_empty, &q->mutex);
    }

    int value = q->buffer[q->out];
    q->out = (q->out + 1) % q->size;
    q->count--;

    pthread_cond_signal(&q->not_full);
    pthread_mutex_unlock(&q->mutex);

    return value;
}
```

### Rust - mpsc（Multiple Producer, Single Consumer）

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 送信側を複数作成
    let tx1 = tx.clone();
    thread::spawn(move || {
        tx1.send(String::from("Hello from thread 1")).unwrap();
    });

    thread::spawn(move || {
        tx.send(String::from("Hello from thread 2")).unwrap();
    });

    // 受信側
    for received in rx {
        println!("Got: {}", received);
    }
}
```

**利点:**
- 簡潔な API
- 型安全
- 所有権の移動により、データ競合を防ぐ

---

## 実践例: 並列計算

### C言語 - pthread

```c
#include <pthread.h>
#include <stdio.h>

#define NUM_THREADS 4
#define ARRAY_SIZE 1000000

int array[ARRAY_SIZE];
long partial_sums[NUM_THREADS];

typedef struct {
    int thread_id;
    int start;
    int end;
} ThreadData;

void *compute_sum(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    long sum = 0;

    for (int i = data->start; i < data->end; i++) {
        sum += array[i];
    }

    partial_sums[data->thread_id] = sum;
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    ThreadData thread_data[NUM_THREADS];

    // 配列を初期化
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array[i] = i;
    }

    // スレッドを起動
    int chunk_size = ARRAY_SIZE / NUM_THREADS;
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_data[i].thread_id = i;
        thread_data[i].start = i * chunk_size;
        thread_data[i].end = (i + 1) * chunk_size;
        pthread_create(&threads[i], NULL, compute_sum, &thread_data[i]);
    }

    // 結果を集計
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    long total = 0;
    for (int i = 0; i < NUM_THREADS; i++) {
        total += partial_sums[i];
    }

    printf("Total sum: %ld\n", total);
    return 0;
}
```

### Rust

```rust
use std::thread;

const NUM_THREADS: usize = 4;
const ARRAY_SIZE: usize = 1_000_000;

fn main() {
    let array: Vec<i32> = (0..ARRAY_SIZE as i32).collect();
    let chunk_size = ARRAY_SIZE / NUM_THREADS;

    let mut handles = vec![];

    for i in 0..NUM_THREADS {
        let start = i * chunk_size;
        let end = (i + 1) * chunk_size;
        let chunk = array[start..end].to_vec();

        let handle = thread::spawn(move || {
            chunk.iter().sum::<i32>() as i64
        });

        handles.push(handle);
    }

    let total: i64 = handles
        .into_iter()
        .map(|h| h.join().unwrap())
        .sum();

    println!("Total sum: {}", total);
}
```

---

## Rayon - データ並列処理

### さらに簡潔な並列処理

```rust
use rayon::prelude::*;

fn main() {
    let array: Vec<i32> = (0..1_000_000).collect();

    let sum: i32 = array.par_iter().sum();

    println!("Total sum: {}", sum);
}
```

**Rayonの利点:**
- 自動的にスレッドプールを管理
- データ並列処理を簡単に記述
- ワークスティーリングによる効率的な負荷分散

---

## デッドロックの防止

### C言語 - 順序が重要（バグりやすい）

```c
pthread_mutex_t mutex1, mutex2;

// スレッド1
void *thread1_func(void *arg) {
    pthread_mutex_lock(&mutex1);
    // ... 処理 ...
    pthread_mutex_lock(&mutex2);  // ←
    // ... 処理 ...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

// スレッド2
void *thread2_func(void *arg) {
    pthread_mutex_lock(&mutex2);  // ← 逆順でロック（デッドロック！）
    // ... 処理 ...
    pthread_mutex_lock(&mutex1);
    // ... 処理 ...
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}
```

### Rust - スコープで自動アンロック

```rust
use std::sync::Mutex;

fn main() {
    let data1 = Mutex::new(0);
    let data2 = Mutex::new(0);

    {
        let mut num1 = data1.lock().unwrap();
        *num1 = 10;
    }  // ← スコープを抜けると自動的にアンロック

    {
        let mut num2 = data2.lock().unwrap();
        *num2 = 20;
    }

    // デッドロックのリスクを最小化
}
```

---

## 組込み開発での並行性

### 割り込みハンドラ（C言語）

```c
#include <stdint.h>

volatile uint32_t tick_count = 0;

// 割り込みハンドラ
void SysTick_Handler(void) {
    tick_count++;  // アトミックでない可能性
}

// メインループ
void main_loop(void) {
    uint32_t last_tick = tick_count;

    while (1) {
        // tick_count の読み取り中に割り込みが入る可能性
        if (tick_count != last_tick) {
            // ... 処理 ...
            last_tick = tick_count;
        }
    }
}
```

### 組込みRust（cortex-m）

```rust
use cortex_m::interrupt::Mutex;
use core::cell::RefCell;

static TICK_COUNT: Mutex<RefCell<u32>> = Mutex::new(RefCell::new(0));

#[interrupt]
fn SysTick() {
    cortex_m::interrupt::free(|cs| {
        let mut count = TICK_COUNT.borrow(cs).borrow_mut();
        *count += 1;
    });
}

fn main_loop() -> ! {
    let mut last_tick = 0;

    loop {
        let current_tick = cortex_m::interrupt::free(|cs| {
            *TICK_COUNT.borrow(cs).borrow()
        });

        if current_tick != last_tick {
            // ... 処理 ...
            last_tick = current_tick;
        }
    }
}
```

---

## まとめ

| 項目 | C言語（pthreads） | Rust |
|------|------------------|------|
| **スレッド作成** | `pthread_create` | `thread::spawn` |
| **型安全性** | なし（`void*`） | あり |
| **データ競合** | 実行時エラー | コンパイルエラー |
| **ミューテックス** | 手動管理 | `Mutex<T>`（型で保護） |
| **共有データ** | グローバル変数 | `Arc<Mutex<T>>` |
| **メッセージパッシング** | 手動実装 | `mpsc::channel` |
| **デッドロック防止** | プログラマ次第 | スコープで自動アンロック |
| **並列処理** | 手動実装 | Rayonなどのライブラリ |

---

## 重要なポイント

### C言語経験者への助言

1. **所有権がスレッド安全性を保証**
   - 所有権を移動 → データ競合なし
   - 借用ルール → 同時アクセスを防ぐ

2. **Send と Sync を理解する**
   - Send: スレッド間で所有権を移動可能
   - Sync: スレッド間で参照を共有可能

3. **Arc<Mutex<T>> パターン**
   - Arc: 参照カウント（スレッド間共有）
   - Mutex: 排他制御

4. **チャネルを活用**
   - 共有メモリより安全
   - 「メモリを共有するな、通信で共有せよ」

---

## 次のステップ

- [[課題07-マルチスレッドファイル処理]] - 並行性を実践
- [[課題09-CLIツール]] - tokioで非同期処理
- [[課題10-WebAPIサーバー]] - 非同期Webサーバー

---

**関連リンク:**
- [The Rust Book: 並行性](https://doc.rust-jp.rs/book-ja/ch16-00-concurrency.html)
- [Rust by Example: Threads](https://doc.rust-jp.rs/rust-by-example-ja/std_misc/threads.html)
- [Rayon Documentation](https://docs.rs/rayon/)
