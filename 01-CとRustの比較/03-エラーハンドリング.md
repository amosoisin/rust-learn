# エラーハンドリング

[[02-ポインタと参照・借用|← 前: ポインタと参照・借用]]  |  [[README|トップに戻る]]  |  [[04-構造体と列挙型|次: 構造体と列挙型 →]]

---

## 概要

C言語のエラーハンドリングは慣習的で、チェック漏れが起こりやすいです。Rustは型システムでエラー処理を強制し、安全性を保証します。

---

## C言語のエラーハンドリング

### 1. 戻り値でエラーを示す

```c
#include <stdio.h>
#include <stdlib.h>

// 成功: 0, 失敗: -1
int read_file(const char *filename, char *buffer, size_t size) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        return -1;  // エラー
    }

    if (fread(buffer, 1, size, fp) == 0) {
        fclose(fp);
        return -1;  // エラー
    }

    fclose(fp);
    return 0;  // 成功
}

int main() {
    char buffer[1024];
    int result = read_file("data.txt", buffer, sizeof(buffer));

    if (result != 0) {  // チェックを忘れがち
        fprintf(stderr, "Error reading file\n");
        return 1;
    }

    printf("%s\n", buffer);
}
```

**問題点:**
- エラーチェックを忘れやすい
- エラーの詳細が不明
- 正常な値とエラーが区別しにくい

### 2. errno によるエラー情報

```c
#include <errno.h>
#include <string.h>

void check_file() {
    FILE *fp = fopen("nonexistent.txt", "r");
    if (fp == NULL) {
        fprintf(stderr, "Error: %s\n", strerror(errno));
        // ENOENT (No such file or directory)
    }
}
```

**問題点:**
- グローバル変数（スレッドセーフでない場合も）
- エラーコードと実際のエラーが分離
- チェック忘れが起こりやすい

### 3. NULLポインタを返す

```c
char *allocate_memory(size_t size) {
    char *ptr = malloc(size);
    return ptr;  // 失敗時はNULL
}

int main() {
    char *data = allocate_memory(1024);
    // NULLチェック忘れ
    strcpy(data, "Hello");  // クラッシュの可能性
}
```

---

## Rustのエラーハンドリング

### Option型 - 値があるかないか

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some(String::from("Alice"))  // 値がある
    } else {
        None  // 値がない
    }
}

fn main() {
    let user = find_user(1);

    match user {
        Some(name) => println!("Found: {}", name),
        None => println!("User not found"),
    }
}
```

**C言語との対比:**
```c
char *find_user(int id) {
    if (id == 1) {
        return "Alice";
    } else {
        return NULL;  // NULLチェック必要
    }
}
```

### Result型 - 成功か失敗か

```rust
use std::fs::File;
use std::io::Read;

fn read_file(filename: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(filename)?;  // ? 演算子でエラー伝播
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)  // 成功
}

fn main() {
    match read_file("data.txt") {
        Ok(contents) => println!("{}", contents),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

**Result型の定義:**
```rust
enum Result<T, E> {
    Ok(T),   // 成功時の値
    Err(E),  // エラー時の値
}
```

---

## エラー処理のパターン

### C言語 - エラーチェックの連鎖

```c
int complex_operation() {
    int result;

    result = step1();
    if (result != 0) {
        return result;
    }

    result = step2();
    if (result != 0) {
        cleanup_step1();
        return result;
    }

    result = step3();
    if (result != 0) {
        cleanup_step2();
        cleanup_step1();
        return result;
    }

    return 0;
}
```

### Rust - ? 演算子

```rust
fn complex_operation() -> Result<(), String> {
    step1()?;  // エラーなら自動的にreturn
    step2()?;
    step3()?;
    Ok(())
}
```

**? 演算子の展開:**
```rust
// step1()? は以下と同等
match step1() {
    Ok(val) => val,
    Err(e) => return Err(e),
}
```

---

## Option型の便利なメソッド

### unwrap_or - デフォルト値

```rust
fn main() {
    let user = find_user(999);
    let name = user.unwrap_or(String::from("Guest"));  // Noneならデフォルト値
    println!("{}", name);  // "Guest"
}
```

**C言語との対比:**
```c
char *user = find_user(999);
char *name = user ? user : "Guest";  // 三項演算子
```

### map - 変換

```rust
fn main() {
    let user = find_user(1);
    let upper = user.map(|name| name.to_uppercase());

    // Some("ALICE") or None
}
```

### and_then - チェーン
>mapメソッドとの違いがまだ分かっていない

```rust
fn get_email(name: &str) -> Option<String> {
    if name == "Alice" {
        Some(String::from("alice@example.com"))
    } else {
        None
    }
}

fn main() {
    let email = find_user(1)
        .and_then(|name| get_email(&name));

    // Some("alice@example.com") or None
}
```

---

## Result型の便利なメソッド

### unwrap と expect

```rust
fn main() {
    // 開発時のみ使用（本番では使わない）
    let contents = read_file("data.txt").unwrap();  // Errならパニック

    // エラーメッセージ付き
    let contents = read_file("data.txt")
        .expect("Failed to read data.txt");
}
```

**注意:** `unwrap()` や `expect()` はC言語の「エラーチェックなし」と似ており、本番コードでは避けるべき。

### map_err - エラーの変換

```rust
use std::num::ParseIntError;

fn parse_number(s: &str) -> Result<i32, String> {
    s.parse::<i32>()
        .map_err(|e| format!("Failed to parse '{}': {}", s, e))
}

fn main() {
    match parse_number("abc") {
        Ok(n) => println!("Number: {}", n),
        Err(e) => eprintln!("Error: {}", e),
        // Error: Failed to parse 'abc': invalid digit found in string
    }
}
```

---

## カスタムエラー型

### C言語 - エラーコード

```c
#define ERR_FILE_NOT_FOUND 1
#define ERR_PERMISSION_DENIED 2
#define ERR_INVALID_FORMAT 3

int process_file(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        if (errno == ENOENT) return ERR_FILE_NOT_FOUND;
        if (errno == EACCES) return ERR_PERMISSION_DENIED;
    }
    // ...
}
```

### Rust - 列挙型

```rust
#[derive(Debug)]
enum FileError {
    NotFound(String),
    PermissionDenied,
    InvalidFormat,
}

fn process_file(filename: &str) -> Result<String, FileError> {
    if filename == "secret.txt" {
        return Err(FileError::PermissionDenied);
    }

    if !filename.ends_with(".txt") {
        return Err(FileError::InvalidFormat);
    }

    // ... 処理 ...
    Ok(String::from("Success"))
}

fn main() {
    match process_file("data.csv") {
        Ok(msg) => println!("{}", msg),
        Err(FileError::NotFound(file)) => {
            eprintln!("File not found: {}", file);
        }
        Err(FileError::PermissionDenied) => {
            eprintln!("Permission denied");
        }
        Err(FileError::InvalidFormat) => {
            eprintln!("Invalid file format");
        }
    }
}
```

---

## 実践例: 設定ファイルの読み込み

### C言語

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char host[256];
    int port;
} Config;

int load_config(const char *filename, Config *config) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        return -1;
    }

    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        char key[128], value[128];
        if (sscanf(line, "%127[^=]=%127s", key, value) == 2) {
            if (strcmp(key, "host") == 0) {
                strncpy(config->host, value, sizeof(config->host) - 1);
            } else if (strcmp(key, "port") == 0) {
                config->port = atoi(value);  // エラーチェックなし
            }
        }
    }

    fclose(fp);
    return 0;
}

int main() {
    Config config = {0};
    if (load_config("config.txt", &config) != 0) {
        fprintf(stderr, "Failed to load config\n");
        return 1;
    }

    printf("Host: %s, Port: %d\n", config.host, config.port);
}
```

### Rust

```rust
use std::fs;
use std::num::ParseIntError;

#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
}

#[derive(Debug)]
enum ConfigError {
    FileError(std::io::Error),
    ParseError(String),
    MissingField(String),
}

impl From<std::io::Error> for ConfigError {
    fn from(err: std::io::Error) -> Self {
        ConfigError::FileError(err)
    }
}

impl From<ParseIntError> for ConfigError {
    fn from(_: ParseIntError) -> Self {
        ConfigError::ParseError(String::from("Invalid port number"))
    }
}

fn load_config(filename: &str) -> Result<Config, ConfigError> {
    let contents = fs::read_to_string(filename)?;

    let mut host = None;
    let mut port = None;

    for line in contents.lines() {
        let parts: Vec<&str> = line.split('=').collect();
        if parts.len() == 2 {
            match parts[0].trim() {
                "host" => host = Some(parts[1].trim().to_string()),
                "port" => port = Some(parts[1].trim().parse()?),
                _ => {}
            }
        }
    }

    Ok(Config {
        host: host.ok_or(ConfigError::MissingField("host".to_string()))?,
        port: port.ok_or(ConfigError::MissingField("port".to_string()))?,
    })
}

fn main() {
    match load_config("config.txt") {
        Ok(config) => {
            println!("Host: {}, Port: {}", config.host, config.port);
        }
        Err(e) => {
            eprintln!("Failed to load config: {:?}", e);
        }
    }
}
```

---

## パニック vs エラー

### パニック - 回復不能なエラー

```rust
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Division by zero!");  // プログラムが停止
    }
    a / b
}
```

**C言語との対比:**
```c
int divide(int a, int b) {
    assert(b != 0);  // assertに失敗したらプログラム停止
    return a / b;
}
```

### Result - 回復可能なエラー

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}
```

**使い分け:**
- **パニック**: プログラムのバグ、回復不能なエラー
- **Result**: 予期されるエラー、ユーザー入力のエラーなど

---

## まとめ

| 項目 | C言語 | Rust |
|------|-------|------|
| **エラー表現** | 戻り値、errno、NULL | Option、Result |
| **チェック強制** | なし | 型システムで強制 |
| **エラー伝播** | 手動 | `?` 演算子 |
| **エラー詳細** | 限定的 | 型に含まれる |
| **安全性** | チェック漏れ可能 | コンパイラが保証 |
| **回復不能** | abort, assert | panic! |

---

## 重要なポイント

### C言語経験者への助言

1. **型でエラーを表現**
   - C言語: 慣習的なエラーコード
   - Rust: Option/Result型で明示

2. **エラーを無視できない**
   - コンパイラが未処理のResultを警告
   - 明示的な処理が必要

3. **? 演算子を活用**
   - エラーチェックの連鎖を簡潔に
   - 早期リターンのパターン

4. **適切なエラー型を選ぶ**
   - Option: 値の有無
   - Result: 成功/失敗とエラー情報
   - panic!: プログラムのバグ

---

## 次のステップ

- [[04-構造体と列挙型]] - カスタムエラー型の設計
- [[課題04-TODOリストCLI]] - Result型を実践
- [[課題06-ログパーサー]] - エラーハンドリングの応用

---

**関連リンク:**
- [The Rust Book: エラー処理](https://doc.rust-jp.rs/book-ja/ch09-00-error-handling.html)
- [Rust by Example: Error handling](https://doc.rust-jp.rs/rust-by-example-ja/error.html)
