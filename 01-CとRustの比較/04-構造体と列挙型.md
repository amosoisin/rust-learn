# 構造体と列挙型

[[03-エラーハンドリング|← 前: エラーハンドリング]]  |  [[README|トップに戻る]]  |  [[05-並行性|次: 並行性 →]]

---

## 概要

RustとC言語は似た構造体（struct）を持ちますが、Rustの列挙型（enum）はより強力で、代数的データ型として機能します。

---

## 構造体（Struct）

### C言語の構造体

```c
typedef struct {
    int x;
    int y;
} Point;

typedef struct {
    char name[50];
    int age;
    Point location;
} Person;

Person create_person(const char *name, int age) {
    Person p;
    strncpy(p.name, name, sizeof(p.name) - 1);
    p.age = age;
    p.location.x = 0;
    p.location.y = 0;
    return p;
}

void print_person(const Person *p) {
    printf("%s, age %d at (%d, %d)\n",
           p->name, p->age, p->location.x, p->location.y);
}
```

### Rustの構造体

```rust
struct Point {
    x: i32,
    y: i32,
}

struct Person {
    name: String,
    age: u32,
    location: Point,
}

fn create_person(name: &str, age: u32) -> Person {
    Person {
        name: name.to_string(),
        age,  // フィールド初期化の省略記法
        location: Point { x: 0, y: 0 },
    }
}

fn print_person(p: &Person) {
    println!("{}, age {} at ({}, {})",
             p.name, p.age, p.location.x, p.location.y);
}
```

---

## メソッドの定義

### C言語 - 関数ポインタ

```c
typedef struct {
    int width;
    int height;
    int (*area)(const struct Rectangle *);  // 関数ポインタ
} Rectangle;

int rectangle_area(const Rectangle *r) {
    return r->width * r->height;
}

Rectangle create_rectangle(int w, int h) {
    Rectangle r = {w, h, rectangle_area};
    return r;
}

int main() {
    Rectangle r = create_rectangle(10, 20);
    printf("Area: %d\n", r.area(&r));
}
```

### Rust - implブロック

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // メソッド（&self を取る）
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // 関連関数（selfを取らない = コンストラクタ的）
    fn new(width: u32, height: u32) -> Self {
        Rectangle { width, height }
    }

    fn square(size: u32) -> Self {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect = Rectangle::new(10, 20);
    println!("Area: {}", rect.area());

    let sq = Rectangle::square(15);
    println!("Square area: {}", sq.area());
}
```

---

## 列挙型（Enum）

### C言語の列挙型 - 単純な定数

```c
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
};

typedef struct {
    enum Status status;
    char message[256];  // エラーメッセージ（無駄なメモリ）
} Response;

Response process() {
    Response r;
    r.status = ERROR;
    strcpy(r.message, "Connection failed");
    return r;
}
```

**問題点:**
- ステータスに応じたデータを効率的に格納できない
- すべてのケースで全フィールドのメモリを確保

### Rustの列挙型 - タグ付きユニオン

```rust
enum Status {
    Ok,
    Error(String),    // エラーの場合のみメッセージを持つ
    Pending,
}

fn process() -> Status {
    Status::Error(String::from("Connection failed"))
}

fn main() {
    let result = process();

    match result {
        Status::Ok => println!("Success"),
        Status::Error(msg) => println!("Error: {}", msg),
        Status::Pending => println!("Waiting..."),
    }
}
```

---

## C言語のunion vs Rustのenum

### C言語 - タグ付きユニオン（手動）

```c
enum ShapeType {
    SHAPE_CIRCLE,
    SHAPE_RECTANGLE
};

typedef struct {
    enum ShapeType type;  // タグ
    union {
        struct {
            double radius;
        } circle;
        struct {
            double width;
            double height;
        } rectangle;
    } data;
} Shape;

double area(const Shape *shape) {
    switch (shape->type) {
        case SHAPE_CIRCLE:
            return 3.14159 * shape->data.circle.radius * shape->data.circle.radius;
        case SHAPE_RECTANGLE:
            return shape->data.rectangle.width * shape->data.rectangle.height;
        default:
            return 0.0;  // タグの整合性は手動管理
    }
}

int main() {
    Shape circle;
    circle.type = SHAPE_CIRCLE;
    circle.data.circle.radius = 5.0;

    // 間違ったタグでアクセス（コンパイラは検出できない）
    // circle.type = SHAPE_RECTANGLE;
    // double w = circle.data.rectangle.width;  // 未定義動作
}
```

### Rust - 型安全な列挙型

```rust
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius } => std::f64::consts::PI * radius * radius,
            Shape::Rectangle { width, height } => width * height,
        }
    }
}

fn main() {
    let circle = Shape::Circle { radius: 5.0 };
    let rect = Shape::Rectangle { width: 10.0, height: 20.0 };

    println!("Circle area: {}", circle.area());
    println!("Rectangle area: {}", rect.area());

    // 間違ったバリアントへのアクセスはコンパイルエラー
    // match circle {
    //     Shape::Rectangle { width, height } => {}  // コンパイルエラー
    // }
}
```

---

## パターンマッチング

### C言語 - switch文

```c
enum Command {
    CMD_QUIT,
    CMD_MOVE,
    CMD_ATTACK
};

void handle_command(enum Command cmd, int x, int y) {
    switch (cmd) {
        case CMD_QUIT:
            printf("Quitting...\n");
            break;
        case CMD_MOVE:
            printf("Moving to (%d, %d)\n", x, y);
            break;
        case CMD_ATTACK:
            printf("Attacking!\n");
            break;
        // default を忘れるとバグの原因に
    }
}
```

### Rust - match式

```rust
enum Command {
    Quit,
    Move { x: i32, y: i32 },
    Attack { target: String },
}

fn handle_command(cmd: Command) {
    match cmd {
        Command::Quit => {
            println!("Quitting...");
        }
        Command::Move { x, y } => {
            println!("Moving to ({}, {})", x, y);
        }
        Command::Attack { target } => {
            println!("Attacking {}", target);
        }
        // すべてのケースを網羅しないとコンパイルエラー
    }
}

fn main() {
    let cmd = Command::Move { x: 10, y: 20 };
    handle_command(cmd);
}
```

---

## Option型とResult型の内部実装

### Option\<T>の定義

```rust
enum Option<T> {
    Some(T),
    None,
}

fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Some(result) => println!("Result: {}", result),
        None => println!("Cannot divide by zero"),
    }
}
```

**C言語での等価なコード:**
```c
typedef struct {
    int has_value;  // 0 = None, 1 = Some
    int value;      // has_value == 1 の時のみ有効
} OptionInt;

OptionInt divide(int a, int b) {
    OptionInt result;
    if (b == 0) {
        result.has_value = 0;
    } else {
        result.has_value = 1;
        result.value = a / b;
    }
    return result;
}
```

---

## 実践例: JSONデータの表現

### C言語

```c
enum JsonType {
    JSON_NULL,
    JSON_BOOL,
    JSON_NUMBER,
    JSON_STRING,
    JSON_ARRAY,
    JSON_OBJECT
};

typedef struct JsonValue JsonValue;

struct JsonValue {
    enum JsonType type;
    union {
        int bool_val;
        double number_val;
        char *string_val;
        struct {
            JsonValue **items;
            size_t len;
        } array_val;
        // ... object_val
    } data;
};

JsonValue *create_number(double num) {
    JsonValue *val = malloc(sizeof(JsonValue));
    val->type = JSON_NUMBER;
    val->data.number_val = num;
    return val;
}

void free_json(JsonValue *val) {
    switch (val->type) {
        case JSON_STRING:
            free(val->data.string_val);
            break;
        case JSON_ARRAY:
            for (size_t i = 0; i < val->data.array_val.len; i++) {
                free_json(val->data.array_val.items[i]);
            }
            free(val->data.array_val.items);
            break;
        // ... 他のケース
    }
    free(val);
}
```

### Rust

```rust
#[derive(Debug)]
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(std::collections::HashMap<String, JsonValue>),
}

impl JsonValue {
    fn new_number(num: f64) -> Self {
        JsonValue::Number(num)
    }

    fn new_array(items: Vec<JsonValue>) -> Self {
        JsonValue::Array(items)
    }
}

fn main() {
    let arr = JsonValue::new_array(vec![
        JsonValue::Number(1.0),
        JsonValue::String(String::from("hello")),
        JsonValue::Bool(true),
    ]);

    println!("{:?}", arr);
    // メモリは自動的に解放される
}
```

---

## Derive属性

### C言語 - 手動実装

```c
typedef struct {
    int x;
    int y;
} Point;

void print_point(const Point *p) {
    printf("Point { x: %d, y: %d }\n", p->x, p->y);
}

Point clone_point(const Point *p) {
    Point new_p;
    new_p.x = p->x;
    new_p.y = p->y;
    return new_p;
}

int points_equal(const Point *a, const Point *b) {
    return a->x == b->x && a->y == b->y;
}
```

### Rust - 自動導出

```rust
#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = p1.clone();

    println!("{:?}", p1);  // Debug
    println!("{}", p1 == p2);  // PartialEq
}
```

**よく使うDerive属性:**
- `Debug`: デバッグ出力
- `Clone`: 明示的なコピー
- `Copy`: 暗黙的なコピー（スタック上の値のみ）
- `PartialEq`: 等価比較
- `Default`: デフォルト値

---

## ジェネリック構造体

### C言語 - 型ごとに定義

```c
// 整数スタック
typedef struct {
    int *data;
    size_t len;
    size_t capacity;
} IntStack;

// 文字列スタック
typedef struct {
    char **data;
    size_t len;
    size_t capacity;
} StringStack;

// ... 型ごとに実装が必要
```

### Rust - ジェネリクス

```rust
struct Stack<T> {
    data: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack { data: Vec::new() }
    }

    fn push(&mut self, item: T) {
        self.data.push(item);
    }

    fn pop(&mut self) -> Option<T> {
        self.data.pop()
    }
}

fn main() {
    let mut int_stack: Stack<i32> = Stack::new();
    int_stack.push(10);
    int_stack.push(20);

    let mut string_stack: Stack<String> = Stack::new();
    string_stack.push(String::from("hello"));
}
```

---

## まとめ

| 項目 | C言語 | Rust |
|------|-------|------|
| **構造体** | `struct` | `struct` |
| **メソッド** | 関数ポインタ | `impl` ブロック |
| **列挙型** | 整数定数 | タグ付きユニオン |
| **union** | 手動タグ管理 | enum で安全に |
| **パターンマッチ** | `switch`（部分的） | `match`（網羅性チェック） |
| **ジェネリクス** | なし（マクロで代用） | 組み込み |
| **自動導出** | なし | `#[derive()]` |
| **メモリ管理** | 手動 | 自動 |

---

## 重要なポイント

### C言語経験者への助言

1. **enum は単なる定数ではない**
   - Rustのenumは強力なデータ型
   - 各バリアントが異なるデータを持てる

2. **match は網羅性をチェック**
   - すべてのケースを処理しないとコンパイルエラー
   - バグの防止に役立つ

3. **impl でメソッドを整理**
   - データと操作を一箇所にまとめる
   - C++のクラスに近い

4. **derive で定型コードを削減**
   - 手動実装の手間を省ける
   - 一貫した実装を保証

---

## 次のステップ

- [[05-並行性]] - スレッドとデータ共有
- [[課題03-CSVパーサー]] - 構造体とenumを実践
- [[課題05-汎用データ構造]] - ジェネリクスの活用

---

**関連リンク:**
- [The Rust Book: 構造体](https://doc.rust-jp.rs/book-ja/ch05-00-structs.html)
- [The Rust Book: 列挙型とパターンマッチング](https://doc.rust-jp.rs/book-ja/ch06-00-enums.html)
- [Rust by Example: Structures](https://doc.rust-jp.rs/rust-by-example-ja/custom_types/structs.html)
