# ポインタと参照・借用

[[01-メモリ管理の比較|← 前: メモリ管理の比較]]  |  [[README|トップに戻る]]  |  [[03-エラーハンドリング|次: エラーハンドリング →]]

---

## 概要

C言語のポインタは強力ですが危険です。Rustの参照と借用システムは、ポインタの利便性を保ちながら、コンパイル時に安全性を保証します。

---

## C言語のポインタ

### 基本的なポインタ

```c
void pointer_basics() {
    int x = 10;
    int *ptr = &x;  // x のアドレスを取得

    printf("%d\n", *ptr);  // 10（デリファレンス）
    *ptr = 20;             // x を変更
    printf("%d\n", x);     // 20
}
```

### ポインタの問題点

#### 1. NULLポインタデリファレンス

```c
int *ptr = NULL;
*ptr = 10;  // クラッシュ！
```

#### 2. ダングリングポインタ

```c
int *dangling() {
    int x = 42;
    return &x;  // スタック変数へのポインタを返す（危険！）
}

int main() {
    int *ptr = dangling();
    printf("%d\n", *ptr);  // 未定義動作
}
```

#### 3. エイリアシング問題

```c
void confusing(int *a, int *b) {
    *a = 10;
    *b = 20;
    // a と b が同じアドレスを指していたら？
    printf("%d\n", *a);  // 20 かもしれない
}
```

---

## Rustの参照と借用

### 不変参照（Immutable Reference）

```rust
fn immutable_reference() {
    let x = 10;
    let r = &x;  // x の不変参照

    println!("{}", r);  // 10
    println!("{}", x);  // 10（x も使える）

    // *r = 20;  // コンパイルエラー！不変参照は変更不可
}
```

**C言語との対比:**
```c
int x = 10;
const int *r = &x;  // const ポインタ（約束だけ）

*r = 20;  // 警告は出るが、キャストすれば可能
```

### 可変参照（Mutable Reference）

```rust
fn mutable_reference() {
    let mut x = 10;
    let r = &mut x;  // x の可変参照

    *r = 20;  // OK（変更可能）
    println!("{}", r);  // 20

    // println!("{}", x);  // コンパイルエラー！
    // 可変参照が存在する間、元の変数は使えない
}
```

**C言語との対比:**
```c
int x = 10;
int *r = &x;

*r = 20;      // OK
printf("%d\n", x);  // OK（C言語では両方使える）
```

---

## 借用ルール（Borrowing Rules）

Rustの最も重要なルール:

### ルール1: 不変参照は複数OK

```rust
fn multiple_immutable() {
    let s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &s;

    println!("{}, {}, {}", r1, r2, r3);  // OK
}
```

### ルール2: 可変参照は同時に1つだけ

```rust
fn one_mutable() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    // let r2 = &mut s;  // コンパイルエラー！

    r1.push_str(", world");
    println!("{}", r1);
}
```

**なぜこのルールが必要？**
```c
// C言語でのデータ競合の例
void data_race() {
    int arr[3] = {1, 2, 3};
    int *p = &arr[0];

    for (int i = 0; i < 3; i++) {
        arr[i] = arr[i] * 2;  // 配列を変更
    }

    printf("%d\n", *p);  // p は古いデータを指している可能性
}
```

### ルール3: 不変参照と可変参照は同時に存在できない

```rust
fn mixed_references() {
    let mut s = String::from("hello");

    let r1 = &s;      // 不変参照
    let r2 = &s;      // 不変参照（OK）
    // let r3 = &mut s;  // コンパイルエラー！

    println!("{}, {}", r1, r2);
}
```

---

## スコープと参照の有効期限

### C言語 - 実行時に問題発生

```c
char *get_string() {
    char buffer[100];
    strcpy(buffer, "Hello");
    return buffer;  // ダングリングポインタ！
}
```

### Rust - コンパイル時にエラー

```rust
fn get_string() -> &str {
    let s = String::from("Hello");
    &s  // コンパイルエラー！
}
```

エラーメッセージ:
```
error[E0515]: cannot return reference to local variable `s`
```

### 正しい方法

```rust
// 方法1: 所有権を移動
fn get_string_owned() -> String {
    let s = String::from("Hello");
    s  // 所有権を返す
}

// 方法2: 静的な文字列リテラル
fn get_string_literal() -> &'static str {
    "Hello"  // プログラム全体で有効
}
```

---

## 関数での参照の使用

### C言語 - ポインタ渡し

```c
void modify(int *x) {
    *x = 20;
}

void read_only(const int *x) {
    printf("%d\n", *x);
    // *x = 10;  // 警告（でも強制ではない）
}

int main() {
    int value = 10;
    modify(&value);
    printf("%d\n", value);  // 20

    read_only(&value);
}
```

### Rust - 借用

```rust
fn modify(x: &mut i32) {
    *x = 20;
}

fn read_only(x: &i32) {
    println!("{}", x);
    // *x = 10;  // コンパイルエラー！
}

fn main() {
    let mut value = 10;
    modify(&mut value);
    println!("{}", value);  // 20

    read_only(&value);
}
```

---

## 構造体とポインタ/参照

### C言語

```c
typedef struct {
    int x;
    int y;
} Point;

void move_point(Point *p, int dx, int dy) {
    p->x += dx;
    p->y += dy;
}

int main() {
    Point p = {10, 20};
    move_point(&p, 5, 10);
    printf("(%d, %d)\n", p.x, p.y);  // (15, 30)
}
```

### Rust

```rust
struct Point {
    x: i32,
    y: i32,
}

fn move_point(p: &mut Point, dx: i32, dy: i32) {
    p.x += dx;
    p.y += dy;
}

fn main() {
    let mut p = Point { x: 10, y: 20 };
    move_point(&mut p, 5, 10);
    println!("({}, {})", p.x, p.y);  // (15, 30)
}
```

---

## 配列とスライス

### C言語 - 配列の減衰

```c
void process_array(int *arr, size_t len) {
    for (size_t i = 0; i < len; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    process_array(arr, 5);  // 配列はポインタに減衰
}
```

### Rust - スライス参照

```rust
fn process_array(arr: &[i32]) {
    for item in arr {
        print!("{} ", item);
    }
}

fn main() {
    let arr = [1, 2, 3, 4, 5];
    process_array(&arr);        // 配列全体
    process_array(&arr[1..4]);  // 部分スライス [2, 3, 4]
}
```

**Rustのスライスの利点:**
- 長さ情報を含む（`len()` メソッド）
- 境界チェックがある
- 安全な部分参照

---

## デリファレンスの自動化

### C言語 - 明示的なデリファレンス

```c
typedef struct {
    int value;
} Container;

void access_field(Container *c) {
    printf("%d\n", c->value);   // -> 演算子
    printf("%d\n", (*c).value); // 明示的デリファレンス
}
```

### Rust - 自動デリファレンス

```rust
struct Container {
    value: i32,
}

fn access_field(c: &Container) {
    println!("{}", c.value);   // 自動デリファレンス
    println!("{}", (*c).value); // 明示的も可能
}
```

---

## NULLポインタ vs Option

### C言語 - NULLチェック

```c
int *find_value(int *arr, size_t len, int target) {
    for (size_t i = 0; i < len; i++) {
        if (arr[i] == target) {
            return &arr[i];
        }
    }
    return NULL;  // 見つからない場合
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int *result = find_value(arr, 5, 3);

    if (result != NULL) {  // NULLチェック（忘れがち）
        printf("Found: %d\n", *result);
    }
}
```

### Rust - Option型

```rust
fn find_value(arr: &[i32], target: i32) -> Option<&i32> {
    for item in arr {
        if *item == target {
            return Some(item);
        }
    }
    None  // 見つからない場合
}

fn main() {
    let arr = [1, 2, 3, 4, 5];
    let result = find_value(&arr, 3);

    match result {
        Some(value) => println!("Found: {}", value),
        None => println!("Not found"),
    }
}
```

---

## 実践例: リンクリスト

### C言語

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

void append(Node **head, int data) {
    Node *new_node = malloc(sizeof(Node));
    new_node->data = data;
    new_node->next = NULL;

    if (*head == NULL) {
        *head = new_node;
        return;
    }

    Node *current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = new_node;
}

void free_list(Node *head) {
    while (head != NULL) {
        Node *temp = head;
        head = head->next;
        free(temp);
    }
}
```

### Rust

```rust
struct Node {
    data: i32,
    next: Option<Box<Node>>,
}

impl Node {
    fn append(&mut self, data: i32) {
        match self.next {
            None => {
                self.next = Some(Box::new(Node {
                    data,
                    next: None,
                }));
            }
            Some(ref mut next_node) => {
                next_node.append(data);
            }
        }
    }
}

// メモリは自動的に解放される
```

---

## まとめ

| 項目 | C言語 | Rust |
|------|-------|------|
| **ポインタ/参照** | ポインタ（`*`） | 不変参照（`&`）、可変参照（`&mut`） |
| **NULL** | あり（危険） | なし（Option型を使用） |
| **エイリアシング** | 制限なし | 借用ルールで制限 |
| **ダングリングポインタ** | 実行時エラー | コンパイルエラー |
| **変更の可視性** | 不明確 | 型で明示（`&` vs `&mut`） |
| **安全性** | プログラマ次第 | コンパイラが保証 |
| **const** | 慣習的 | 強制される |

---

## 重要なポイント

### C言語経験者への助言

1. **不変参照がデフォルト**
   - C言語: `const` は明示的
   - Rust: `&` がデフォルトで不変

2. **可変参照の排他性**
   - データ競合を言語レベルで防ぐ
   - マルチスレッドでも安全

3. **Option型を活用**
   - NULLチェック忘れを防ぐ
   - 型システムで強制

4. **借用チェッカーと仲良くする**
   - 最初は厳しく感じる
   - 慣れると実行時バグが激減

---

## 次のステップ

- [[03-エラーハンドリング]] - Result型の使い方を学ぶ
- [[課題02-文字列操作ツール]] - &str vs String を実践
- [[課題03-CSVパーサー]] - 参照を使ったデータ処理

---

**関連リンク:**
- [The Rust Book: 参照と借用](https://doc.rust-jp.rs/book-ja/ch04-02-references-and-borrowing.html)
- [Rust by Example: Borrowing](https://doc.rust-jp.rs/rust-by-example-ja/scope/borrow.html)
